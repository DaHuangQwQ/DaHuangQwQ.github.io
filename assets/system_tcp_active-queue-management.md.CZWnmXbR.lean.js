import{_ as a,c as t,a2 as o,o as n}from"./chunks/framework.BQmytedh.js";const m=JSON.parse('{"title":"主动队列管理","description":"","frontmatter":{},"headers":[],"relativePath":"system/tcp/active-queue-management.md","filePath":"system/tcp/active-queue-management.md"}'),i={name:"system/tcp/active-queue-management.md"};function r(s,e,l,c,d,u){return n(),t("div",null,e[0]||(e[0]=[o('<h1 id="主动队列管理" tabindex="-1">主动队列管理 <a class="header-anchor" href="#主动队列管理" aria-label="Permalink to &quot;主动队列管理&quot;">​</a></h1><p>路由器通过一种通常叫做_主动队列管理_ (Active Queue Management，AQM)的方法参与拥塞控制。AQM 本质是一种拥塞规避方法，即使与 Control-Based 的算法例如 TCP Reno 一起工作，也是如此。</p><p>虽然更改路由器行为从来不是互联网引入新功能的首选方式，但是对于拥塞控制来说，人们普遍同意路由器处于检测拥塞发生的理想位置——因为正是路由器的队列被填满导致了拥塞。但对于什么是最佳算法人们并没有达成一致意见，本章描述了两种经典机制，并总结了一下业界的现状。</p><h2 id="decbit" tabindex="-1">DECbit <a class="header-anchor" href="#decbit" aria-label="Permalink to &quot;DECbit&quot;">​</a></h2><h2 id="random-early-detection" tabindex="-1">Random Early Detection <a class="header-anchor" href="#random-early-detection" aria-label="Permalink to &quot;Random Early Detection&quot;">​</a></h2><h2 id="controlled-delay" tabindex="-1">Controlled Delay <a class="header-anchor" href="#controlled-delay" aria-label="Permalink to &quot;Controlled Delay&quot;">​</a></h2><h2 id="explicit-congestion-notification" tabindex="-1">Explicit Congestion Notification <a class="header-anchor" href="#explicit-congestion-notification" aria-label="Permalink to &quot;Explicit Congestion Notification&quot;">​</a></h2><h2 id="ingress-egress-queue" tabindex="-1">Ingress/Egress Queue <a class="header-anchor" href="#ingress-egress-queue" aria-label="Permalink to &quot;Ingress/Egress Queue&quot;">​</a></h2>',8)]))}const p=a(i,[["render",r]]);export{m as __pageData,p as default};
