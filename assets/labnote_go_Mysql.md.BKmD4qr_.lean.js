import{_ as i,c as o,a2 as e,o as a}from"./chunks/framework.BQmytedh.js";const r="/assets/f273652a-5940-4789-bc51-1e3a06a8bf51.D_z58G2-.png",t="/assets/f94eddb4-3f26-42ff-9613-f3b1273f8443.BEJaPIFz.png",b=JSON.parse('{"title":"Mysql","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/go/Mysql.md","filePath":"labnote/go/Mysql.md"}'),n={name:"labnote/go/Mysql.md"};function s(d,l,p,g,u,h){return a(),o("div",null,l[0]||(l[0]=[e('<h1 id="mysql" tabindex="-1">Mysql <a class="header-anchor" href="#mysql" aria-label="Permalink to &quot;Mysql&quot;">​</a></h1><h2 id="存储引擎" tabindex="-1">存储引擎 <a class="header-anchor" href="#存储引擎" aria-label="Permalink to &quot;存储引擎&quot;">​</a></h2><p>MySQL 的主要存储引擎包括</p><ol><li>InnoDB（重点）： 支持事务、行级锁和外键 提供高并发性能，适用于高负载的 OLTP 应用 数据以聚集索引的方式存储，提高检索效率</li><li>MyISAM（重点）： 不支持事务和外键，使用表级锁 适合读取多、更新少的场景，如数据仓库。 具有较高的读性能和较快的表级锁定。</li><li>MEMORY： 数据存储在内存中，速度快，但数据在服务器重启后丢失 适用于临时数据存储或快速缓存</li><li>NDB： 支持高可用性和数据分布，适合大规模分布式应用 提供行级锁和自动分区</li><li>ARCHIVE： 用于存储大量历史数据，支持高效的插入和压缩。 不支持索引，适合日志数据存储。</li></ol><h2 id="索引类型" tabindex="-1">索引类型 <a class="header-anchor" href="#索引类型" aria-label="Permalink to &quot;索引类型&quot;">​</a></h2><p>从数据结构角度来看，MVSQL 索引可以分为以下几类</p><ul><li>B+树索引</li><li>哈希索引</li><li>倒排索引(Full-Text)</li><li>R-树索引(多维空间树)</li></ul><p>从常见的基于 InnoDB B+ 树索引角度来看，可以分为</p><ul><li>聚簇索引(Clustered lndex)</li><li>非聚簇索引(Non-clustered Index)</li></ul><p>从索引性质的角度来看，可以分为:</p><ul><li>普通索引(二级索引、辅助索引)</li><li>主键索引</li><li>联合索引</li><li>唯一索引</li><li>全文索引</li><li>空间索引</li></ul><h3 id="数据排序" tabindex="-1">数据排序 <a class="header-anchor" href="#数据排序" aria-label="Permalink to &quot;数据排序&quot;">​</a></h3><ul><li>如果命中索引，利用索引排序</li><li>反之文件排序，数据量少在内存中排序，数据量大在磁盘文件进行外部排序，一般使用归并排序</li></ul><h3 id="b-树索引" tabindex="-1">B+树索引 <a class="header-anchor" href="#b-树索引" aria-label="Permalink to &quot;B+树索引&quot;">​</a></h3><p><strong>B+树的查询过程</strong>：</p><ol><li>数据从根节点找起，根据比较数据键值与节点中存储的索引键值，确定数据落在哪个区间，从而确定分支，从上到下最终定位到叶子节点</li><li>叶子节点存储实际的数据行记录，但是一页有 16kb 大小，存储的数据行不止一条</li><li>叶子节点中数据行以组的形式划分，利用页目录结构，通过二分查找可以定位到对应的组</li><li>定位组后，利用链表遍历就可以找到对应的数据行</li></ol><p>高效的查询性能：</p><ul><li>B+ 树是一种平衡树，保证了从每个叶子节点到根节点的路径长度相同，确保了查找、插入和删除等操作的时间复杂度为 O(log⁡n)O(\\log n)O(logn)，即使在大数据量情况下，也能保证快速的响应时间。</li></ul><p>树的高度增长不会过快，减少查询磁盘 I/O 次数：</p><ul><li>与红黑树不同，B+ 树的数据增长不会导致高度增长过快。由于它是多叉树，非叶子节点仅保存主键或索引值和页面指针，这样每一页能容纳更多的记录，减少了查询时磁盘 I/O 的次数。</li></ul><p>范围查询能力强：</p><ul><li>B+ 树特别适合范围查询，因为它通过节点间的链表连接，能够快速定位查询范围的起始点，并通过顺序扫描链表来获取连续的数据，效率较高。</li></ul><p><strong>聚簇索引</strong>： 索引叶子结点存储的是数据行，可以直接访问完整数据。每个表只能有一个聚簇索引，通常是主键索引，适合范围查询和排序 <strong>非聚簇索引</strong>： 索引叶子节点存储的是数据行的主键和对应的索引列，需通过主键才能访问完整的数据行。一个表可以有多个非聚簇索引(称之为非主键索引、辅助索引、二级索引)，适用于快速查找特定列的数据</p><blockquote><p>&quot;回表&quot;是指在使用二级索引（非聚簇索引）作为条件进行查询时，由于二级索引中只存储了索引字段的值和对应的主键值，无法得到其它数据。如果要查询数据行中的其它数据，需要根据主键去聚簇索引查找实际的数据行，这个过程被称为回表，<strong>会带来随机IO</strong></p></blockquote><p><strong>最左匹配原则</strong>：</p><p>MySQL 索引的最左前缀匹配原则指的是在使用联合索引时，查询条件必须从索引的最左侧开始匹配。</p><p><strong>覆盖索引</strong>：</p><p>MySQL 的覆盖索引（Covering index）是指二级索引中包含了查询所需的所有字段，从而使查询可以仅通过访问二级索引而不需要访问实际的表数据（主键索引）</p><p><strong>索引下推</strong>：</p><p>索引下推（index Condition Pushdown，ICP）是一种减少回表查询，提高查询效率的技术，索引下推就是通过二级索引查到主键id后回表完再进行where条件过滤 改为 =&gt; 二级索引查到数据后直接where过滤一遍 再进行回表 减少回表的次数</p><h3 id="自增主键" tabindex="-1">自增主键 <a class="header-anchor" href="#自增主键" aria-label="Permalink to &quot;自增主键&quot;">​</a></h3><p>一句话解释自增主键，就是为了提高性能。自增主键从两方面提高性能：</p><ul><li>自增主键可以使得新插入的记录在物理上总是出现在已有记录的后面，避免了页分裂，减少了索引碎片，提升了插入和查询的性能；</li><li>自增主键可以优化页的利用，减少磁盘 I/O 和内存使用，因为数据是按顺序写入的。并且在范围查询的时候，如果结果集是连续的，那么这些数据很有可能在同一页，或者相邻的页上，这样能够充分利用预读的特性。</li></ul><p>除了这两个关键好处以外，从工程上来说自增主键也有好处：</p><ul><li>从代码落地的角度上来说，可以避免自己手动生成、管理主键的问题；</li><li>可以统一规定使用自增主键，而不必担忧因为团队规模扩大导致大家胡乱使用主键；</li></ul><blockquote><p>预读；页分裂；减少页分裂，优化页利用；</p></blockquote><p>一般来说，只有在没有进行分库分表的时候，我们才会选择自增主键。在分库分表的时候，自增主键就不太好用了。</p><p>不过在分库分表环境下，也可以通过设置步长来使用自增主键。例如说分了三个表，那么就可以将步长设置为 3，并且每个表从不同的起点开始自增。具体来说，第一个表就可以按照 1, 4 ,7 ... 的规律使用自增主键，第二个表按照 2,5,8... 的规律使用自增主键，以及第三个表就用 3,6,9 ... 的规律来使用自增主键。</p><p>即便排除这种用法，在分库分表的环境下依旧会尽量让生成的主键保持单调递增，以尽量获得和自增主键差不多的优势。</p><h2 id="实现事务" tabindex="-1">实现事务 <a class="header-anchor" href="#实现事务" aria-label="Permalink to &quot;实现事务&quot;">​</a></h2><p>MySQL 通过锁、Redo Log、Undo Log 和 MVCC 等机制确保事务的原子性、隔离性和持久性，保证数据库的一致性和高并发性能。</p><ol><li><strong>锁机制</strong>： <ul><li>MySQL 使用锁（如行锁、间隙锁等）来控制数据的并发访问和修改，确保事务的隔离性。</li></ul></li><li><strong>Redo Log（重做日志）</strong>： <ul><li>Redo Log 用于记录事务对数据库的所有修改，它可以帮助在 MySQL 崩溃或宕机后，通过重放 Redo Log 恢复数据，从而保证事务的持久性。</li></ul></li><li><strong>Undo Log（回滚日志）</strong>： <ul><li>Undo Log 用于记录事务的反向操作，简单来说，就是保存数据的历史版本，以便事务失败时能够回滚到事务开始前的状态，确保原子性和隔离性。</li></ul></li><li><strong>MVCC（多版本并发控制）</strong>： <ul><li>MVCC 通过多版本机制提高了并发性能，满足了读写并发需求，能够支持读已提交和可重复读两种隔离级别，实现事务的隔离性。</li></ul></li></ol><h2 id="mvcc" tabindex="-1">MVCC <a class="header-anchor" href="#mvcc" aria-label="Permalink to &quot;MVCC&quot;">​</a></h2><h3 id="版本链" tabindex="-1">版本链 <a class="header-anchor" href="#版本链" aria-label="Permalink to &quot;版本链&quot;">​</a></h3><p>我们先来看第一个存储不同版本的数据。MVCC 将数据的不同版本存储在 undo log 里面。undo log 是 MySQL 中和事务密切有关的概念，主要是用于在事务回滚的时候，能够将数据恢复到事务开始之前的状态。</p><p>在 undo log 里面使用版本链将数据不同的版本串联起来了，你可以注意到，上图里面 x 这一条数据有两个额外的列：trx_id，事务 ID，你可以认为它代表的就是版本；roll_ptr，回滚指针，实质上就是用它来将不同版本串联在了一起。</p><h3 id="read-view" tabindex="-1">Read View <a class="header-anchor" href="#read-view" aria-label="Permalink to &quot;Read View&quot;">​</a></h3><p>那么当一个事务执行的时候，它在这么长的一个链条里面，就要考虑读数据应该读哪个版本了——也就是读哪个事务 ID 对应的数据。这个过程是通过一个称为 Read View 的机制来实现的，它也就是 MySQL 中实现不同隔离级别的核心机制。</p><p>Read View，如果要是我来翻译的话，我会翻译为<strong>可见视图</strong>，也就是说 Read View 决定了你这个事务能看到什么版本的数据。暂时你可以理解为，这个 Read View 就是记录了哪些事务 ID 对于当下这个正在执行的事务来说是可见的。</p><p>这里我们深入分析已提交读和可重复读。</p><ul><li>对于已提交读来说，每次执行读数据的时候都会生成一个 Read View。</li><li>对于可重复读来说，在事务开始的时候生成一个 Read View，后面都用这个 Read View。</li></ul><p>所以你瞬间就懂了可重复读的精髓—— Read View 始终都是那一个，后续就算事务执行过程中有新事务提交了，但是 Read View 没有更新，读到的就还是历史版本，也就是你事务开启时候的那一个版本的数据。</p><p>而 Read View 记录哪些事务是可见，哪些事务不可见的原理有点违反直觉，它记录的是 m_ids，也就是当前事务开启的时候，数据库上别的还没提交的事务 ID。那么很显然，假设说现在有一个事务的 ID 是 10，并且 m_ids = 7,8，那么在事务开启的时候：</p><ul><li>9 是可见的，因为 9 在事务 10 开始的时候已经提交了；</li><li>7 和 8 是不可见的，因为它们还没有提交</li><li>1...6 都是可见的，因为它们也已经提交了</li></ul><p>假设说现在有一个新的事务又开始了，ID 是 11，在 11 没有提交的时候，它都是不可见的（除非你是未提交读）。当 11 提交之后：</p><ul><li>如果是已提交读，重新生成一个 Read View，那么这时候数据库就会发现，11 已经提交了，那么它就可见了；</li><li>如果是可重复读，那么 Read View 还是那个 Read View，而 11 不在 m_ids 中，说明是事务 10 生成之后开启的事务，就算提交了也不可见；</li></ul><p>而与 MVCC 还强关联的一个概念是 redo log，它实际上并不是为了支撑 MVCC 而引入的，它是为了事务提交之后崩溃，还能恢复过来而引入的。</p><blockquote><p>怎么存，undo log；怎么取，Read View</p></blockquote><p>MVCC，全称是多版本并发控制，是 MySQL InnoDB 中用来实现事务，以及事务隔离级别的核心机制。</p><p>它的关键点有两个：存储不同版本的数据以及如何控制事务读取哪个版本的事务。</p><p>就存储来说，MVCC 使用了版本链。每一条数据都有两个额外的列，一个是事务 ID，也可以看做是版本号；一个是回滚指针，MVCC 利用回滚指针将数据不同的版本串联在一起，并且将这个版本链存储到了 undo log 日志中。</p><p>而后，MVCC 使用 Read View 来做数据可见性控制，它记录了生成 Read View 时候还保持活跃的事务。在已提交读的情况下，事务会在每次执行读数据的时候，就重新生成一个 Read View，这样可以保证能够立刻看到最新的提交的事务。</p><p>而在可重复读的情况下，只会在事务 BEGIN 的时候生成一个 Read View，后面都是使用这个 Read View。</p><p>和 MVCC，或者说和事务实现机制有关的是 redo log，但是一般来说 redo log 是用于事务恢复的。例如说事务提交之后数据库就立刻崩溃了，工作还没做完，那么就需要从 redo log 来恢复数据，保证数据一致性。</p><h3 id="隔离级别" tabindex="-1">隔离级别 <a class="header-anchor" href="#隔离级别" aria-label="Permalink to &quot;隔离级别&quot;">​</a></h3><ol><li><strong>读未提交（READ UNCOMMITTED）</strong>： <ul><li>这是最低的隔离级别。</li><li>一个事务可以看到另一个事务尚未提交的数据修改。</li><li>可能导致<strong>脏读</strong>问题，即读取到其他事务未提交的数据。</li></ul></li><li><strong>读已提交（READ COMMITTED）</strong>： <ul><li>一个事务只能看到已经提交的其他事务所做的修改。</li><li>可以避免脏读问题，但可能会引发<strong>不可重复读</strong>问题，即在同一个事务中，相同的查询可能返回不同的结果，被另一个事务更改。</li></ul></li><li><strong>可重复读（REPEATABLE READ）</strong>： <ul><li>确保在一个事务中的多个查询返回的结果是一致的。</li><li>可以避免不可重复读问题，但可能会引发<strong>幻读</strong>问题，即在同一个事务中，多次查询可能返回不同数量的行，另一个事务添加行。</li><li><strong>MySQL默认的隔离级别</strong>。</li></ul></li><li><strong>串行化（SERIALIZABLE）</strong>： <ul><li>并发SQL事务在SERIALIZABLE隔离级别下的执行被保证是可串行化的。</li><li>可串行化执行被定义为：并发执行的SQL事务的操作，其效果与这些SQL事务按某种顺序串行执行的效果相同。</li><li>串行执行是指每个SQL事务在下一个SQL事务开始之前完成其全部操作。</li><li>这是最高的隔离级别，保证事务间的操作结果相当于一个按顺序执行的单线程操作。</li><li>可以避免所有的并发问题，但会大大降低并发性能。</li></ul></li></ol><h2 id="undo-log" tabindex="-1">undo log <a class="header-anchor" href="#undo-log" aria-label="Permalink to &quot;undo log&quot;">​</a></h2><p>undo log 这个名字叫就已经揭示了它的作用，它的核心作用有两个：</p><ul><li><strong>支持回滚操作</strong></li><li><strong>支持 MVCC</strong></li></ul><p>回滚操作进一步划分也可以分成是用户主动回滚——调用了 ROLLBACK，或者被动回滚——数据库崩溃之后恢复，但是核心步骤是类似的。</p><p>undo log 中记录了两大类东西：</p><ul><li>MVCC 使用版本链</li><li>事务操作的逆向操作，它针对增删改记录了不同的信息： <ul><li>对于 INSERT 操作来说，它记录了完整的行，那么回滚的时候就可以根据这个行来找到被插入的数据，而后执行删除。</li><li>对于 UPDATE 来说，它记录了受影响的行修改之前的值；</li><li>对于 DELETE 来说，它记录了被删除的行的主键，删除操作在 MYSQL 执行的时候只是把数据标记为被删除，并没有真的删除，所以回滚的时候就是把这个被删除的标记位去掉。</li></ul></li></ul><p>使用 INSERT 操作时，undo log 不仅仅记录了 ID，一般是整个数据都记录下来了，只是说回滚的时候只需要 id 就可以定位到了。</p><p>使用 UPDATE 操作时，为了记录 undo log，UPDATE 执行的时候会先解析 WHERE 条件，定位到被更新的数据之后，才能记录 undo log。</p><blockquote><p>这个有点类似于我们在分布式事务里面讨论的，如果要生成反向操作，你需要先知道老的数据是什么。</p></blockquote><p>而 undo log 自身也可以看做是一个链表：</p><p><img src="'+r+'" alt="img" loading="lazy"></p><h2 id="redo-log" tabindex="-1">redo log <a class="header-anchor" href="#redo-log" aria-label="Permalink to &quot;redo log&quot;">​</a></h2><p>redo log 的主要作用是确保事务的持久性，即使在发生故障时也能保持数据库的一致性。它和 undo log 是相辅相成的，undo log 是在崩溃的时候回滚，而 redo log 是在崩溃的时候重新执行事务。</p><p>所以用 undo log 回滚还是用 redo log 重做事务，就取决于事务有没有被提交。</p><p>你可能很难理解，就是为什么事务提交了，数据库崩溃了，还要用 redo log 来重做事务。这其实有一个点：事务修改数据只是修改 buffer pool，后续再异步的刷新到磁盘上。也就是说当你的业务收到 COMMIT 成功的响应的时候，数据可能还在磁盘上。</p><p><img src="'+t+'" alt="img" loading="lazy"></p><p>这个时候就有一个时间差了，我事务提交了，但是我还没修改磁盘上上的数据，这不就是寄了吗？因此 redo log 就是为了解决这个问题的。因此在修改数据的时候，其实是先写 redo log，再修改 buffer pool。</p><p>这时候你就有疑问了，干嘛不直接写磁盘，又写 redo log，又写 buffer pool 的。这就要说到 redo log 的特性了，redo log 本身是一种 WAL（Write-Ahead Log），也就是顺序写的日志，只追加不修改。所以它的性能非常好，极快。</p><p>相当于，如果你直接修改磁盘上的数据，那就是随机写；但是你写 redo log，那就是顺序写。而众所周知，顺序写比随机写快多了。</p><p>但是这又会有一个问题，redo log 最开始是写到了 redo log buffer 上，而你 redo log 也得刷盘啊。</p><p>这个刷盘行为由 innodb_flush_log_at_trx_commit 来控制：</p><ul><li>0：每秒刷新到磁盘，是从 redo log buffer 到磁盘。</li><li>1：每次提交的时候刷新到磁盘上，也就是最安全的选项，InnoDB 的<strong>默认值</strong>。</li><li>2：每次提交的时候刷新到 page cache 里，依赖于操作系统后续刷新到磁盘。而操作系统什么时候刷，就不知道了；</li></ul><p>因此很显然，这就有一个问题：如果要是用了参数 0 和 2，那么你业务收到提交成功的时候，redo log 都还在磁盘上，如果此时宕机，一样会丢掉数据。类似的，参数是 2 也会有问题。</p><h2 id="mysql-锁" tabindex="-1">Mysql 锁 <a class="header-anchor" href="#mysql-锁" aria-label="Permalink to &quot;Mysql 锁&quot;">​</a></h2><p>MYSQL 的锁机制，有很多角度可以回答:</p><ul><li>行锁与表锁：是锁住行还是锁住表；</li><li>共享锁与排它锁：这是指一个人加了锁之后，另外一个人还能不能加锁；</li><li>意向锁：就是想加锁，但是没加锁的意向；</li><li>记录锁、临键锁和间隙锁：这有点类似行锁还是表锁，描述的是锁的范围，但是这个更加详细： <ul><li>记录锁：锁住特定的行</li><li>间隙锁：锁住行之间的间隙</li><li>临键锁：next-key lock，不管是英文名还是中文译名都很难理解，简单说，记录锁 + 间隙锁合并在一起就是临键锁了</li></ul></li></ul><p>而后你要记得提起一个点，就是如果在查询中查询没有命中任何索引，那么就会使用表锁。这种情况下，性能衰减非常可怕。</p><p>同时也要表达自己的态度，即优先考虑使用乐观锁，并且如果你有使用乐观锁来优化悲观锁的案例，也可以顺便提及。</p><p>另外一个就是隔离级别和锁的关系的问题，这主要影响的是临键锁和间隙锁，这两种锁只工作在可重复读这个隔离级别下。</p><p>不建议在数据库中直接使用 SELECT FOR UPDATE 之类的这种悲观锁，而是更加倾向于使用乐观锁。通过使用乐观锁来优化了很多 SELECT FOR UPDATE 的这种写法，一方面提高了性能，一方面也规避了死锁等问题。</p><p>同时应该把隔离级别调整到已提交读上，这样可以减少 MYSQL 使用锁。例如说间隙锁和临键锁就是工作在可重复读这个隔离级别的。通常我们说已提交读的性能会更好，也有锁这个原因。</p><h3 id="记录锁、临键锁和间隙锁" tabindex="-1">记录锁、临键锁和间隙锁 <a class="header-anchor" href="#记录锁、临键锁和间隙锁" aria-label="Permalink to &quot;记录锁、临键锁和间隙锁&quot;">​</a></h3><ol><li>记录锁：首先记录锁针对的是一条条的数据，例如说在使用等值查询的时候，一般加的就是记录锁。</li><li>隙锁针：对的是某一个范围，但是间隙锁一般不包含端点。</li><li>临键锁：可以看做是记录锁和间隙锁的结合。</li></ol><p>具体什么时候加什么锁，是比较复杂的，但是我有一个简单的原则可以快速判定：等值查询记录锁，范围查询间隙锁，端点存在临键锁。</p><h3 id="悲观锁和乐观锁" tabindex="-1">悲观锁和乐观锁 <a class="header-anchor" href="#悲观锁和乐观锁" aria-label="Permalink to &quot;悲观锁和乐观锁&quot;">​</a></h3><p><strong>悲观锁（Pessimistic Locking）</strong>：适合并发冲突多，写多读少</p><ul><li>假设会发生冲突，因此在操作数据之前就对数据加锁，确保其他事务无法访问该数据。常见于对数据一致性要求较高的场景。</li><li>实现方式：使用行级锁或表级锁，例如可以使用 <code>SELECT ... FOR UPDATE</code> 或 <code>LOCK IN SHARE MODE</code> 语句来加锁。</li></ul><p><strong>乐观锁（Optimistic Locking）</strong>：适合并发冲突小，读多写少</p><ul><li>假设不会发生冲突，因此在操作数据时不加锁，而是在更新数据时进行版本控制或校验。如果发现数据被其他事务修改，则会拒绝当前事务的修改，需重新尝试。</li><li>实现方式：通常通过版本号或时间戳来实现，每次更新时检查版本号或时间戳是否一致。</li></ul><h2 id="主从同步" tabindex="-1">主从同步 <a class="header-anchor" href="#主从同步" aria-label="Permalink to &quot;主从同步&quot;">​</a></h2><h3 id="复制类型" tabindex="-1">复制类型 <a class="header-anchor" href="#复制类型" aria-label="Permalink to &quot;复制类型&quot;">​</a></h3><ul><li><strong>异步复制</strong>：主库不需要等待从库的响应（性能较高，数据一致性低）。</li><li><strong>同步复制</strong>：主库同步等待所有从库确认收到数据（性能差，数据一致性高）。</li><li><strong>半同步复制</strong>：主库等待至少一个从库确认收到数据（性能折中，数据一致性较高）。</li></ul><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><h3 id="explain" tabindex="-1">EXPLAIN <a class="header-anchor" href="#explain" aria-label="Permalink to &quot;EXPLAIN&quot;">​</a></h3><p>在MySQL中，<code>EXPLAIN</code> 是一个非常有用的SQL语句，用于分析查询语句的执行计划。执行计划是数据库如何执行查询语句的详细步骤，包括如何访问数据（使用索引还是全表扫描）、如何连接表等。通过分析执行计划，你可以了解查询的性能瓶颈，并进行相应的优化。</p><ol><li><strong>id</strong>：查询中执行的顺序标识（从1开始）。</li><li><strong>select_type</strong>：查询的类型（如SIMPLE, PRIMARY, SUBQUERY等）。</li><li><strong>table</strong>：正在访问的表的名称。</li><li><strong>partitions</strong>：匹配的分区。</li><li><strong>type</strong>：连接类型（如ALL, index, range, ref, eq_ref等）。</li><li><strong>possible_keys</strong>：查询中可能使用的索引。</li><li><strong>key</strong>：实际使用的索引。</li><li><strong>key_len</strong>：使用的索引的长度。</li><li><strong>ref</strong>：显示索引的哪一列被使用。</li><li><strong>rows</strong>：估计需要读取的行数。</li><li><strong>filtered</strong>：表示此查询的表的行被过滤的百分比。</li><li><strong>Extra</strong>：额外的信息，如是否使用了索引，是否需要排序等。</li></ol><h3 id="调优" tabindex="-1">调优 <a class="header-anchor" href="#调优" aria-label="Permalink to &quot;调优&quot;">​</a></h3><p>平时进行SQL调优，主要是通过以下方法：</p><ol><li>合理设计索引，利用联合索引进行覆盖索引的优化，避免回表的发生，减少一次查询和随机I/O。</li><li>避免使用 <code>SELECT *</code>，只查询必要的字段。</li><li>避免在SQL中进行函数计算等操作，使得无法命中索引。</li><li>避免使用 <code>%LIKE</code>，导致全表扫描。</li><li>注意联合索引需满足最左匹配原则。</li><li>不要对无索引字段进行排序操作。</li><li>连表查询需要注意不同字段的字符集是否一致，否则也会导致全表扫描。</li></ol><p>除此之外，还可以：</p><ul><li>利用缓存来优化，一些变化少或者访问频繁的数据设置到缓存中，减轻数据库的压力，提升查询的效率。</li><li>通过业务来优化，例如少展示一些不必要的字段，减少多表查询的情况，将列表查询替换成分页分批查询等等。</li></ul>',117)]))}const q=i(n,[["render",s]]);export{b as __pageData,q as default};
