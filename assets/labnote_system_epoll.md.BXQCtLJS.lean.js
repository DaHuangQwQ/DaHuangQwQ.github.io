import{_ as i,c as a,a2 as s,o as e}from"./chunks/framework.BQmytedh.js";const c=JSON.parse('{"title":"epoll","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/system/epoll.md","filePath":"labnote/system/epoll.md"}'),t={name:"labnote/system/epoll.md"};function p(n,l,h,o,d,r){return e(),a("div",null,l[0]||(l[0]=[s(`<h1 id="epoll" tabindex="-1">epoll <a class="header-anchor" href="#epoll" aria-label="Permalink to &quot;epoll&quot;">​</a></h1><p>linux 内核提供了三种经典的多路复用技术：select、poll、epoll</p><h3 id="_1-select" tabindex="-1">（1）select <a class="header-anchor" href="#_1-select" aria-label="Permalink to &quot;（1）select&quot;">​</a></h3><ul><li>一次可以处理多个 fd，体现多路. 但 fd 数量有限，最多 1024 个</li><li>loop thread 通过 select 将一组 fd 提交到内核做监听</li><li>当 fd 中无 io event 就绪时，loop thread 会陷入阻塞</li><li>每当这组 fd 中有 io event 到达时，内核会唤醒 loop thread</li><li>loop thread 无法精准感知到哪些 fd 就绪，需要遍历一轮 fd 列表，时间复杂度 O(N)</li><li>托付给内核的 fd 列表只具有一轮交互的时效. 新的轮次中，loop thread 需要重新将监听的 fd 列表再传递给内核一次</li></ul><h3 id="_2-epoll" tabindex="-1">（2）epoll <a class="header-anchor" href="#_2-epoll" aria-label="Permalink to &quot;（2）epoll&quot;">​</a></h3><ul><li>每次处理的 fd 数量无上限</li><li>loop thread 通过 epoll_create 操作创建一个 epoll 池子</li><li>loop thread 通过 epoll_ctl 每次将一个待监听的 fd 添加到 epoll 池中</li><li>每当 fd 列表中有 fd 就绪事件到达时，会唤醒 loop thread. 同时内核会将处于就绪态的 fd 直接告知 loop thread，无需额外遍历</li></ul><p>综上所述，select 和 epoll 等多路复用操作利用了内核的能力，能在待监听 fd 中有 io event 到达时，将 loop thread 唤醒，避免无意义的主动轮询操作.</p><p>其中，epoll 相比于 select 的核心性能优势在于：</p><ul><li>• loop thread 被唤醒时，能明确知道哪些 fd 需要处理，减少了一次额外遍历的操作，时间复杂度由 O(N) 优化到 O(1)</li><li>• epoll 通过将创建池子和添加 fd两个操作解耦，实现了池中 fd 数据的复用，减少了用户态与内核态间的数据拷贝成本</li></ul><h2 id="边缘触发和水平触发" tabindex="-1">边缘触发和水平触发 <a class="header-anchor" href="#边缘触发和水平触发" aria-label="Permalink to &quot;边缘触发和水平触发&quot;">​</a></h2><p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT）</strong>。</p><p>这两个术语还挺抽象的，其实它们的区别还是很好理解的。</p><ul><li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完</li><li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取</li></ul><h2 id="event-poll-原理" tabindex="-1">Event poll 原理 <a class="header-anchor" href="#event-poll-原理" aria-label="Permalink to &quot;Event poll 原理&quot;">​</a></h2><p>epoll 又称 EventPoll，使用很简单，包含三个指令“</p><ul><li>epoll_create</li><li>epoll_ctl</li><li>epoll_wait</li></ul><p>下面我们逐一展开聊聊：</p><h3 id="_1-epoll-create" tabindex="-1">（1）epoll_create <a class="header-anchor" href="#_1-epoll-create" aria-label="Permalink to &quot;（1）epoll_create&quot;">​</a></h3><p>在内核开辟空间，创建一个 epoll 池子用于批量存储管理 fd，后续可以通过 epoll_ctl 往池子中增删改 fd.</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> epollcreate1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flags</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32</span></span></code></pre></div><h3 id="_2-epoll-ctl" tabindex="-1">（2）epoll_ctl <a class="header-anchor" href="#_2-epoll-ctl" aria-label="Permalink to &quot;（2）epoll_ctl&quot;">​</a></h3><p>在某个 epoll 池子中进行一个 fd 的增删改操作.</p><p>正是由于 epoll 中将 epoll_ctl 与 epoll_create 操作进行了解耦，才实现了对 epoll_create 时传递的 fd 数据的复用，减少了用户态和内核态之间对 fd 数据的重复传递</p><p>此外，在 epoll_ctl 实现时，也需要通过 epollevent 设置好回调事件，当 fd 有指定事件到达时，会被添加到就绪队列中，最终将 loop thread 唤醒.</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> epollctl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">epfd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">op</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ev</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">epollevent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> epollevent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    events </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint32</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    data   [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // unaligned uintptr</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3-epoll-wait" tabindex="-1">（3）epoll_wait <a class="header-anchor" href="#_3-epoll-wait" aria-label="Permalink to &quot;（3）epoll_wait&quot;">​</a></h3><p>从对应 epoll 池子中获取就绪的 epollevent，从中可以关联到对应的 fd 和 loop thread 信息.</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> epollwait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">epfd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ev</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">epollevent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">timeout</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int32</span></span></code></pre></div><h2 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h2><h3 id="_1-epoll-池红黑树" tabindex="-1">（1）epoll 池红黑树 <a class="header-anchor" href="#_1-epoll-池红黑树" aria-label="Permalink to &quot;（1）epoll 池红黑树&quot;">​</a></h3><p>一个 epoll 池子中管理的 fd 数量理论上上不封顶. 同时后续可能存在对 fd 的增删改操作，因此需要使用合适的数据结构加以管理，从而降低后续操作的时间复杂度.</p><p>linux 内核中，实现 epoll 池的数据结构采用的是红黑树（Red-Black Tree，一种自平衡二叉查找树，这里不作展开，感兴趣自行了解）实现，保证了所有增、删、改操作的平均时间复杂度维持在 O(logN) 的对数级水平.</p><h3 id="_2-就绪事件队列" tabindex="-1">（2）就绪事件队列 <a class="header-anchor" href="#_2-就绪事件队列" aria-label="Permalink to &quot;（2）就绪事件队列&quot;">​</a></h3><p>针对于 fd 的就绪 io event，由于通常数量有限，且每个事件都需要逐一处理，没有优先级之分，因此采用简单的双向链表实现即可.</p><h2 id="事件回调机制" tabindex="-1">事件回调机制 <a class="header-anchor" href="#事件回调机制" aria-label="Permalink to &quot;事件回调机制&quot;">​</a></h2><p>epoll 高效的核心建立在精准的事件回调机制之上.</p><p>首先，通过内核感知到 io event 事件的动态，令 loop thread 在合适的时机阻塞，避免浪费 CPU；在合适的时机执行，及时处理 io event.</p><p>其次，在 io event 就绪时，会精准地将真正就绪的 fd 传递到 loop thread 手中，减少了一次无意义的遍历查询动作.</p><p>事件回调的注册是在调用 epoll_ctl 添加 fd 时，此时会提前设置好对这个 fd 关心的事件类型，当对应的 io event 真的发生时，内核会将该 fd 和对应的 loop thread 封装到 epollevent 中，添加到就绪队列 ready list 当中.</p><p>之后当用户调用 epoll_wait 时，能够准确地获取到这部分就绪的 epollevent，进而能够将对应的 loop thread 唤醒.</p>`,40)]))}const g=i(t,[["render",p]]);export{c as __pageData,g as default};
