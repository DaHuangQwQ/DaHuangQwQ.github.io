import{_ as a,c as e,o as i,V as l}from"./chunks/framework.WykxUCM3.js";const f=JSON.parse('{"title":"缓存","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/go/cache.md","filePath":"labnote/go/cache.md"}'),h={name:"labnote/go/cache.md"},r=l('<h1 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h1><h2 id="缓存模式" tabindex="-1">缓存模式 <a class="header-anchor" href="#缓存模式" aria-label="Permalink to &quot;缓存模式&quot;">​</a></h2><h3 id="cache-aside" tabindex="-1">Cache Aside <a class="header-anchor" href="#cache-aside" aria-label="Permalink to &quot;Cache Aside&quot;">​</a></h3><ul><li>把 Cache 当成一个普通的数据源</li><li>更新 Cache 和 DB 都依赖于开发者自己写代码</li></ul><p><strong>业务代码</strong>可以做决策:</p><ul><li>未命中的时候是否要从 DB 取数据。如果不从 DB 取，可以考虑使用默认值进行业务处理</li><li>同步 or 异步读取数据并且写入</li><li>采用 singleflight</li></ul><h3 id="read-through" tabindex="-1">Read Through <a class="header-anchor" href="#read-through" aria-label="Permalink to &quot;Read Through&quot;">​</a></h3><ul><li>业务代码只需要从 cache 中读取数据，cache 会在缓存不命中的时候去读取数据</li><li>写数据的时候，业务代码需要自己写 DB 和写 cache</li></ul><p><strong>cache</strong> 可以做决策:</p><ul><li><p>未命中的时候是否要从 DB 取数据。如果不从 DB 取，可以考虑使用默认值进行业务处理</p></li><li><p>同步 or 异步读取数据并且写入</p></li><li><p>采用 singleflight</p></li></ul><h3 id="write-through" tabindex="-1">Write Through <a class="header-anchor" href="#write-through" aria-label="Permalink to &quot;Write Through&quot;">​</a></h3><ul><li>开发者只需要写入 cache，cache 自己会更新数据库</li><li>在读未命中缓存的情况下，开发者需要自己去数据库捞数据，然后更新缓存(此时缓存不需要更新 DB 了)</li></ul><h3 id="write-back" tabindex="-1">Write Back <a class="header-anchor" href="#write-back" aria-label="Permalink to &quot;Write Back&quot;">​</a></h3><ul><li>在写操作的时候写了缓存直接返回，不会直接更新数据库，读也是直接读缓存</li><li>在缓存过期的时候，将缓存写回去数据库</li><li>所有 goroutine 都是读写缓存，不存在一致性的问题(如果是本地缓存依旧会有问题)</li><li>数据可能丢失:如果在缓存过期刷新到数据库之前，缓存宕机，那么会丢失数据</li></ul><h3 id="refresh-ahead" tabindex="-1">Refresh Ahead <a class="header-anchor" href="#refresh-ahead" aria-label="Permalink to &quot;Refresh Ahead&quot;">​</a></h3><p>refresh-ahead 依赖于 CDC(changed data capture) 接口: • 数据库暴露数据变更接口</p><ul><li>cache 或者第四方在监听到数据变更之后自动更新数据</li><li>如果读 cache 未命中，依旧要刷新缓存的话，依然会出现并发问题</li></ul>',17),t=[r];function o(c,n,s,d,u,_){return i(),e("div",null,t)}const g=a(h,[["render",o]]);export{f as __pageData,g as default};
