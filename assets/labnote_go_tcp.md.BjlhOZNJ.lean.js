import{_ as t,c as i,a2 as a,o as r}from"./chunks/framework.BQmytedh.js";const o="/assets/image-20250216005703769.wMwTtALX.png",e="/assets/image-20250216011330879.Dj6D4Pf-.png",n="/assets/3.I7SCM7OP.jpg",P=JSON.parse('{"title":"tcp","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/go/tcp.md","filePath":"labnote/go/tcp.md"}'),s={name:"labnote/go/tcp.md"};function d(h,l,u,c,p,C){return r(),i("div",null,l[0]||(l[0]=[a('<h1 id="tcp" tabindex="-1">tcp <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;tcp&quot;">​</a></h1><h2 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-label="Permalink to &quot;http&quot;">​</a></h2><h3 id="http-1-0" tabindex="-1">HTTP/1.0 <a class="header-anchor" href="#http-1-0" aria-label="Permalink to &quot;HTTP/1.0&quot;">​</a></h3><ul><li>增加了 HEAD、POST 等新方法。</li><li>增加了响应状态码。</li><li>引入了头部，即请求头和响应头。</li><li>在请求中加入了 HTTP 版本号。</li><li>引入了 Content-Type，使得传输的数据不再限于文本。</li></ul><h3 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP/1.1&quot;">​</a></h3><ul><li>新增了连接管理即 keepalive，允许持久连接。</li><li>支持 pipeline，无需等待前面的请求响应，即可发送第二次请求。</li><li>允许响应数据分块（chunked），即响应的时候不标明 Content-Length，客户端就无法断开连接，直到收到服务端的 EOF，利于传输大文件。</li><li>新增缓存的控制和管理。</li><li>加入了 Host 头，用在你一台机子部署了多个主机，然后多个域名解析又是同一个 IP，此时加入了 Host 头就可以判断你到底是要访问哪个主机。</li></ul><h3 id="http-2" tabindex="-1">HTTP/2 <a class="header-anchor" href="#http-2" aria-label="Permalink to &quot;HTTP/2&quot;">​</a></h3><ul><li>是二进制协议，不再是纯文本。</li><li>支持一个 TCP 连接发起多请求，移除了 pipeline。</li><li>利用 HPACK 压缩头部，减少数据传输量。</li><li>允许服务端主动推送数据。</li></ul><h3 id="http-3-0" tabindex="-1">HTTP/3.0 <a class="header-anchor" href="#http-3-0" aria-label="Permalink to &quot;HTTP/3.0&quot;">​</a></h3><ul><li>基于UDP，使用QUIC协议（Quick UDP Internet Connections），提供类似TCP的可靠性和多路复用。</li><li>通过QUIC协议，避免了TCP队头阻塞，即使在网络不稳定的情况下也能提供更好的性能。</li><li>默认使用QUIC自带的TLS 1.3加密，安全性更高，且加密是强制的。</li><li>QUIC集成了连接建立和加密握手，连接建立速度更快，尤其在初次连接时。</li></ul><h2 id="tcp-解决的问题" tabindex="-1">TCP 解决的问题 <a class="header-anchor" href="#tcp-解决的问题" aria-label="Permalink to &quot;TCP 解决的问题&quot;">​</a></h2><ol><li><strong>可靠性传输：</strong><ul><li>TCP确保数据包在网络传输过程中不丢失、不重复，并且按顺序到达。通过确认（ACK）、重传机制以及序列号，TCP能够保证数据在不可靠的IP网络上可靠传输。</li></ul></li><li><strong>流量控制：</strong><ul><li>TCP通过滑动窗口机制调节发送方的数据发送速率，防止接收方因为处理能力有限而被数据流淹没。</li></ul></li><li><strong>拥塞控制：</strong><ul><li>TCP通过拥塞避免算法（如慢启动、拥塞避免、快速重传和快速恢复）来防止网络过载，确保网络资源的公平使用和稳定性。</li></ul></li><li><strong>连接管理：</strong><ul><li>TCP是面向连接的协议，采用三次握手（建立连接）和四次挥手（断开连接）机制来管理会话，确保通信的可靠性和状态的同步。</li></ul></li></ol><h2 id="内容" tabindex="-1">内容 <a class="header-anchor" href="#内容" aria-label="Permalink to &quot;内容&quot;">​</a></h2><ol><li><strong>数据包重排序与重传机制：</strong><ul><li>TCP的序列号机制确保数据包按照正确的顺序组装。接收方通过序列号识别数据包的顺序，如果检测到丢失或乱序的包，会请求重传，保证数据完整性。</li></ul></li><li><strong>滑动窗口与流量控制：</strong><ul><li>滑动窗口用于动态调整可以发送的数据量。接收方通过发送窗口大小通告，指示发送方可以发送的最大数据量。这种机制不仅避免了接收方的溢出，还提高了数据传输效率。</li></ul></li><li><strong>拥塞控制算法：</strong><ul><li>TCP的拥塞控制算法是核心的网络稳定性保证。经典算法包括以下几个步骤： <ul><li>慢启动：逐步增加发送窗口，直到检测到网络的拥塞点。</li><li>拥塞避免：当达到网络容量后，逐渐增加窗口以避免拥塞。</li><li>快速重传和快速恢复：在检测到包丢失时，立即进行重传并调整发送窗口，快速恢复正常传输状态。</li></ul></li></ul></li><li><strong>TCP三次握手与四次挥手：</strong><ul><li>三次握手：建立连接时，双方通过三次信息交换（SYN, SYN-ACK, ACK）来确保双方都准备好进行数据传输，并协商参数（如初始序列号）。</li><li>四次挥手：断开连接时，通过四次消息交换来确保数据传输完成且资源可以安全释放，防止未传输的数据丢失。</li></ul></li><li><strong>TCP的适应性与演变：</strong><ul><li>随着互联网的发展，TCP也经历了多次改进，如TCP Reno、TCP NewReno、TCP Vegas等，它们在拥塞控制和流量管理上有不同策略，以适应不同的网络环境。</li></ul></li><li><strong>TCP的局限性：</strong><ul><li>虽然TCP解决了可靠传输的问题，但在高延迟、高带宽的网络（如卫星通信、现代数据中心）中可能会受到性能瓶颈，进而催生了如QUIC等新协议的出现。</li></ul></li></ol><h2 id="tcp-与-udp-的区别" tabindex="-1">TCP 与 UDP 的区别 <a class="header-anchor" href="#tcp-与-udp-的区别" aria-label="Permalink to &quot;TCP 与 UDP 的区别&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接方式</td><td>面向连接</td><td>无连接</td></tr><tr><td>可靠性</td><td>提供可靠性，保证数据按顺序到达</td><td>不可靠，不保证顺序或完整性</td></tr><tr><td>流量控制/拥塞控制</td><td>提供流量控制和拥塞控制</td><td>没有流量控制和拥塞控制</td></tr><tr><td>顺序保证</td><td>保证数据顺序</td><td>不保证数据顺序</td></tr><tr><td>头部大小</td><td>较大（20字节及以上）</td><td>较小（8字节）</td></tr><tr><td>性能</td><td>较低，延迟大</td><td>较高，延迟小</td></tr><tr><td>数据传输模式</td><td>字节流传输模式</td><td>数据报传输模式</td></tr><tr><td>适用场景</td><td>文件传输、Web、邮件等需要可靠性的应用</td><td>实时通讯、语音、视频、游戏等高性能要求应用</td></tr><tr><td>是否能粘包</td><td>是</td><td>否</td></tr></tbody></table><h2 id="粘包与拆包" tabindex="-1">粘包与拆包 <a class="header-anchor" href="#粘包与拆包" aria-label="Permalink to &quot;粘包与拆包&quot;">​</a></h2><ol><li><strong>粘包与拆包（也称半包）现象：</strong><ul><li><strong>粘包：</strong> 在TCP传输中，发送方的多个数据包在接收方被合并成一个包接收，导致多条消息数据粘在一起，接收方无法正确区分这些消息的边界。</li><li><strong>拆包：</strong> 发送方的一个数据包在接收方被分成了多个包接收，导致一条完整的消息被拆成多个部分，接收方无法一次性接收到完整的数据。</li></ul></li><li><strong>原因：</strong><ul><li><strong>粘包：</strong> 主要由于TCP是面向字节流的协议，它不关心数据边界，数据在发送方可能被一次性发送，接收方在读取时可能会将多个消息拼接在一起。</li><li><strong>拆包：</strong> 可能由于网络传输中的MTU（最大传输单元）限制或发送缓冲区大小限制，一个大包被分成了多个小包传输。</li></ul></li><li><strong>解决方法：</strong><ul><li><strong>使用定长消息：</strong> 每个消息都有固定的长度，接收方按照固定长度读取数据。</li><li><strong>添加消息分隔符：</strong> 在每个消息之间添加特定的分隔符（如换行符），接收方可以通过分隔符来区分消息。</li><li><strong>使用消息头：</strong> 在消息的头部添加一个长度字段，指示消息的长度，接收方根据这个长度来读取相应长度的数据。</li></ul></li></ol><h2 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h2><ol><li>客户端发送SYN包请求连接。</li><li>服务器收到SYN包后，返回SYN+ACK包，表示同意连接并等待客户端确认。</li><li>客户端收到SYN+ACK包后，发送ACK包确认，连接建立。</li></ol><p>为了阻止历史的重复连接初始化导致的混乱</p><p><img src="'+o+'" alt="image-20250216005703769" loading="lazy"></p><h3 id="syn" tabindex="-1">SYN <a class="header-anchor" href="#syn" aria-label="Permalink to &quot;SYN&quot;">​</a></h3><p>在TCP（传输控制协议）中，SYN（Synchronize Sequence Numbers，同步序列号）是一个用于建立连接的特殊标志位。它在TCP三次握手过程中起着至关重要的作用，确保了两个通信实体之间能够建立一个可靠的连接</p><ol><li><strong>连接建立失败的情况</strong>： <ul><li>客户端发送SYN包至服务器后宕机。</li><li>服务器发送SYN+ACK包，但一直未收到客户端的ACK响应。</li><li>服务器会进行阶段性重试。</li></ul></li><li><strong>重试机制</strong>： <ul><li>重试次数由系统参数<code>tcp_synack_retries</code>决定。</li><li>在Linux系统中，默认重试次数为5次。</li><li>重试是阶梯性的，间隔时间分别为1秒、2秒、4秒、8秒、16秒。</li><li>第五次重试后，还需要等待32秒才能知道这次重试的结果。</li></ul></li><li><strong>总等待时间</strong>： <ul><li>总共需要等待63秒才能断开连接并释放资源。</li></ul></li></ol><h3 id="syn-flood-攻击" tabindex="-1">SYN Flood 攻击 <a class="header-anchor" href="#syn-flood-攻击" aria-label="Permalink to &quot;SYN Flood 攻击&quot;">​</a></h3><p>SYN Flood是一种拒绝服务攻击（DoS），通过发送大量SYN包耗尽服务器资源，使服务器无法响应用户连接请求。</p><p>利用TCP三次握手机制，攻击者发送大量SYN包但不完成后续握手步骤（不发送ACK），导致服务器在等待未完成连接状态下耗尽资源。</p><h2 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h2><p>除了四次挥手断开连接，还有 RST（Reset）标志强制断开、超时</p><p>为什么要四次挥手</p><ul><li>主要是为了确保数据完整性。</li><li>TCP是一个全双工协议，双方都要关闭，每一方都向对方发送FIN和回应ACK。</li><li>客户端发起连接断开，代表客户端没有数据要发送的，但是服务端可能还有数据没有返回给客户端。</li><li>就像我对你说你数据发完了，然后你回复好的你收到了。然后你对我说你数据发完了，然后我向你回复我收到了。这样才能保证数据不会丢失。</li><li>所以一个FIN+ACK代表一方结束数据的传输，因此需要两对FIN+ACK，加起来就是四次通信。</li></ul><p>如果 Client 发送 FIN 给 server 的时候已经没数据发送给 Client 了，那么 Server 就可以将 ACK 和它的 FIN 一起发给 Client，这样就变成<strong>三次挥手</strong></p><ol><li><strong>第一次挥手（FIN → ACK）</strong>： <ul><li>客户端主动关闭连接，发送FIN包，进入FIN_WAIT_1状态。</li><li>服务器收到FIN后，表示不再接收数据，但仍可能继续发送数据。</li></ul></li><li><strong>第二次挥手（ACK）</strong>： <ul><li>服务器发送ACK包，确认已收到FIN。</li><li>此时服务器进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。</li></ul></li><li><strong>第三次挥手（FIN → ACK）</strong>： <ul><li>服务器完成所有数据传输后，发送FIN包，进入LAST_ACK状态。</li><li>客户端收到FIN后，准备关闭连接。</li></ul></li><li><strong>第四次挥手（ACK）</strong>： <ul><li>客户端发送最后一个ACK包，进入TIME_WAIT状态，等待可能迟到的FIN包。</li><li>服务器收到ACK后，关闭连接，进入CLOSED状态。</li><li>客户端在TIME_WAIT计时结束后（2MSL），正式关闭连接。</li></ul></li></ol><p><img src="'+e+'" alt="image-20250216011330879" loading="lazy"></p><h3 id="time-wait-作用" tabindex="-1">TIME_WAIT 作用 <a class="header-anchor" href="#time-wait-作用" aria-label="Permalink to &quot;TIME_WAIT 作用&quot;">​</a></h3><ol><li>确保最后的ACK被成功接收：</li></ol><ul><li>在TCP四次挥手过程中，主动关闭连接的一方在发送最后一个ACK确认包后进入TIME_WAIT状态。</li><li>如果这个ACK丢失了，另一方（被动关闭连接的一方）没有收到确认包，会重发FIN报文。主动关闭的一方需要在TIME_WAIT状态下保持一段时间，以便能够重发ACK，确保连接能被正确地关闭。</li></ul><ol start="2"><li>防止旧的重复分段干扰新连接：</li></ol><ul><li>TCP连接在关闭后，可能会有一些延迟的或者已经失效的报文还在网络中传输。如果立即重新使用相同的IP地址和端口建立新的连接，可能会受到这些旧报文的干扰。</li><li>TIME_WAIT状态可以确保在旧连接的所有报文都超时失效后，才允许新的连接使用相同的IP地址和端口，从而避免数据混乱。</li></ul><h2 id="isn" tabindex="-1">ISN <a class="header-anchor" href="#isn" aria-label="Permalink to &quot;ISN&quot;">​</a></h2><p>在TCP协议中，ISN（Initial Sequence Number，初始序列号）是建立连接时为每个TCP连接分配的一个起始序列号。序列号是TCP协议用于数据传输的重要机制</p><ul><li>ISN是以时间戳为基础生成的，这意味着ISN的生成与系统时间相关，以确保每次生成的ISN都是唯一的。</li><li>根据RFC 793，ISN的生成与一个假的时钟绑定在一起。这个时钟每四微秒增加1，这为ISN提供了一个递增的基础值。</li><li>当ISN达到2的32次方（即232）时，它会回绕到0并重新开始计数。这意味着大约每4.5小时（具体时间取决于计数速率），ISN会经历一次回绕。</li><li>为了提高安全性，实际的ISN实现中会加入一些随机值。这样做是为了防止不法份子通过预测ISN的生成模式来发起攻击，如SYN洪水攻击。</li><li>通过在ISN生成中加入随机值，可以使得ISN的预测变得更加困难，从而提高了TCP连接的安全性。</li></ul><h2 id="流量控制" tabindex="-1">流量控制 <a class="header-anchor" href="#流量控制" aria-label="Permalink to &quot;流量控制&quot;">​</a></h2><p>滑动窗口</p><ul><li>TCP滑动窗口机制的主要作用是实现流量控制（Flow Control），即协调发送方和接收方的数据传输速率，确保发送方不会发送超出接收方处理能力的数据量，防止接收端缓冲区溢出。</li><li>滑动窗口允许发送方在未收到前一个数据包的确认（ACK）前继续发送多个数据包，从而提高网络吞吐量，减少等待时间，实现高效的数据流传输。</li></ul><h2 id="拥塞控制" tabindex="-1">拥塞控制 <a class="header-anchor" href="#拥塞控制" aria-label="Permalink to &quot;拥塞控制&quot;">​</a></h2><p>慢启动（Slow Start）：</p><ul><li>发送方在连接建立初期，缓慢地增加数据发送速率。初始的拥塞窗口（cwnd）通常为一个MSS（最大报文段大小），然后在每次收到ACK后成倍增加cwnd，直到达到慢启动阈值（ssthresh）或检测到网络拥塞。</li></ul><p>拥塞避免（Congestion Avoidance）：</p><ul><li>当cwnd达到ssthresh后，TCP进入拥塞避免阶段，拥塞窗口的增长速度从指数变为线性增长，即每个RTT（往返时间）增加一个MSS。这一阶段旨在避免激烈的拥塞反应，保持网络稳定性。</li></ul><p>快速重传（Fast Retransmit）：</p><ul><li>发送方在收到三个重复的ACK后，立即重传被认为丢失的报文段，而无需等待超时。这减少了重传的延迟，迅速应对数据丢失。</li></ul><p>快速恢复（Fast Recovery）：</p><ul><li>在快速重传后，TCP不进入慢启动，而是减小cwnd到当前的一半，并设置ssthresh为当前新的cwnd的值，然后开始线性增加cwnd，以快速恢复到丢包前的传输速率。</li></ul><h2 id="半连接队列和全连接队列" tabindex="-1">半连接队列和全连接队列 <a class="header-anchor" href="#半连接队列和全连接队列" aria-label="Permalink to &quot;半连接队列和全连接队列&quot;">​</a></h2><p><img src="'+n+'" alt="半连接队列与全连接队列" loading="lazy"></p><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；</li><li>全连接队列，也称 accept 队列；</li></ul><p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></p><p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h2>',62)]))}const g=t(s,[["render",d]]);export{P as __pageData,g as default};
