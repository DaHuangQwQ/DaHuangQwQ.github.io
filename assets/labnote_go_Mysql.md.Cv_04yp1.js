import{_ as o,c as e,a2 as a,o as i}from"./chunks/framework.BQmytedh.js";const p="/assets/f273652a-5940-4789-bc51-1e3a06a8bf51.D_z58G2-.png",d="/assets/f94eddb4-3f26-42ff-9613-f3b1273f8443.BEJaPIFz.png",b=JSON.parse('{"title":"Mysql","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/go/Mysql.md","filePath":"labnote/go/Mysql.md"}'),r={name:"labnote/go/Mysql.md"};function t(n,l,u,s,g,c){return i(),e("div",null,l[0]||(l[0]=[a('<h1 id="mysql" tabindex="-1">Mysql <a class="header-anchor" href="#mysql" aria-label="Permalink to &quot;Mysql&quot;">​</a></h1><h2 id="自增主键" tabindex="-1">自增主键 <a class="header-anchor" href="#自增主键" aria-label="Permalink to &quot;自增主键&quot;">​</a></h2><p>一句话解释自增主键，就是为了提高性能。自增主键从两方面提高性能：</p><ul><li>自增主键可以使得新插入的记录在物理上总是出现在已有记录的后面，避免了页分裂，减少了索引碎片，提升了插入和查询的性能；</li><li>自增主键可以优化页的利用，减少磁盘 I/O 和内存使用，因为数据是按顺序写入的。并且在范围查询的时候，如果结果集是连续的，那么这些数据很有可能在同一页，或者相邻的页上，这样能够充分利用预读的特性。</li></ul><p>除了这两个关键好处以外，从工程上来说自增主键也有好处：</p><ul><li>从代码落地的角度上来说，可以避免自己手动生成、管理主键的问题；</li><li>可以统一规定使用自增主键，而不必担忧因为团队规模扩大导致大家胡乱使用主键；</li></ul><blockquote><p>预读；页分裂；减少页分裂，优化页利用；</p></blockquote><p>一般来说，只有在没有进行分库分表的时候，我们才会选择自增主键。在分库分表的时候，自增主键就不太好用了。</p><p>不过在分库分表环境下，也可以通过设置步长来使用自增主键。例如说分了三个表，那么就可以将步长设置为 3，并且每个表从不同的起点开始自增。具体来说，第一个表就可以按照 1, 4 ,7 ... 的规律使用自增主键，第二个表按照 2,5,8... 的规律使用自增主键，以及第三个表就用 3,6,9 ... 的规律来使用自增主键。</p><p>即便排除这种用法，在分库分表的环境下依旧会尽量让生成的主键保持单调递增，以尽量获得和自增主键差不多的优势。</p><h2 id="mvcc" tabindex="-1">MVCC <a class="header-anchor" href="#mvcc" aria-label="Permalink to &quot;MVCC&quot;">​</a></h2><h3 id="版本链" tabindex="-1">版本链 <a class="header-anchor" href="#版本链" aria-label="Permalink to &quot;版本链&quot;">​</a></h3><p>我们先来看第一个存储不同版本的数据。MVCC 将数据的不同版本存储在 undo log 里面。undo log 是 MySQL 中和事务密切有关的概念，主要是用于在事务回滚的时候，能够将数据恢复到事务开始之前的状态。</p><p>在 undo log 里面使用版本链将数据不同的版本串联起来了，你可以注意到，上图里面 x 这一条数据有两个额外的列：trx_id，事务 ID，你可以认为它代表的就是版本；roll_ptr，回滚指针，实质上就是用它来将不同版本串联在了一起。</p><h3 id="read-view" tabindex="-1">Read View <a class="header-anchor" href="#read-view" aria-label="Permalink to &quot;Read View&quot;">​</a></h3><p>那么当一个事务执行的时候，它在这么长的一个链条里面，就要考虑读数据应该读哪个版本了——也就是读哪个事务 ID 对应的数据。这个过程是通过一个称为 Read View 的机制来实现的，它也就是 MySQL 中实现不同隔离级别的核心机制。</p><p>Read View，如果要是我来翻译的话，我会翻译为<strong>可见视图</strong>，也就是说 Read View 决定了你这个事务能看到什么版本的数据。暂时你可以理解为，这个 Read View 就是记录了哪些事务 ID 对于当下这个正在执行的事务来说是可见的。</p><p>这里我们深入分析已提交读和可重复读。</p><ul><li>对于已提交读来说，每次执行读数据的时候都会生成一个 Read View。</li><li>对于可重复读来说，在事务开始的时候生成一个 Read View，后面都用这个 Read View。</li></ul><p>所以你瞬间就懂了可重复读的精髓—— Read View 始终都是那一个，后续就算事务执行过程中有新事务提交了，但是 Read View 没有更新，读到的就还是历史版本，也就是你事务开启时候的那一个版本的数据。</p><p>而 Read View 记录哪些事务是可见，哪些事务不可见的原理有点违反直觉，它记录的是 m_ids，也就是当前事务开启的时候，数据库上别的还没提交的事务 ID。那么很显然，假设说现在有一个事务的 ID 是 10，并且 m_ids = 7,8，那么在事务开启的时候：</p><ul><li>9 是可见的，因为 9 在事务 10 开始的时候已经提交了；</li><li>7 和 8 是不可见的，因为它们还没有提交</li><li>1...6 都是可见的，因为它们也已经提交了</li></ul><p>假设说现在有一个新的事务又开始了，ID 是 11，在 11 没有提交的时候，它都是不可见的（除非你是未提交读）。当 11 提交之后：</p><ul><li>如果是已提交读，重新生成一个 Read View，那么这时候数据库就会发现，11 已经提交了，那么它就可见了；</li><li>如果是可重复读，那么 Read View 还是那个 Read View，而 11 不在 m_ids 中，说明是事务 10 生成之后开启的事务，就算提交了也不可见；</li></ul><p>而与 MVCC 还强关联的一个概念是 redo log，它实际上并不是为了支撑 MVCC 而引入的，它是为了事务提交之后崩溃，还能恢复过来而引入的。</p><blockquote><p>怎么存，undo log；怎么取，Read View</p></blockquote><p>MVCC，全称是多版本并发控制，是 MySQL InnoDB 中用来实现事务，以及事务隔离级别的核心机制。</p><p>它的关键点有两个：存储不同版本的数据以及如何控制事务读取哪个版本的事务。</p><p>就存储来说，MVCC 使用了版本链。每一条数据都有两个额外的列，一个是事务 ID，也可以看做是版本号；一个是回滚指针，MVCC 利用回滚指针将数据不同的版本串联在一起，并且将这个版本链存储到了 undo log 日志中。</p><p>而后，MVCC 使用 Read View 来做数据可见性控制，它记录了生成 Read View 时候还保持活跃的事务。在已提交读的情况下，事务会在每次执行读数据的时候，就重新生成一个 Read View，这样可以保证能够立刻看到最新的提交的事务。</p><p>而在可重复读的情况下，只会在事务 BEGIN 的时候生成一个 Read View，后面都是使用这个 Read View。</p><p>和 MVCC，或者说和事务实现机制有关的是 redo log，但是一般来说 redo log 是用于事务恢复的。例如说事务提交之后数据库就立刻崩溃了，工作还没做完，那么就需要从 redo log 来恢复数据，保证数据一致性。</p><h2 id="undo-log" tabindex="-1">undo log <a class="header-anchor" href="#undo-log" aria-label="Permalink to &quot;undo log&quot;">​</a></h2><p>undo log 这个名字叫就已经揭示了它的作用，它的核心作用有两个：</p><ul><li><strong>支持回滚操作</strong></li><li><strong>支持 MVCC</strong></li></ul><p>回滚操作进一步划分也可以分成是用户主动回滚——调用了 ROLLBACK，或者被动回滚——数据库崩溃之后恢复，但是核心步骤是类似的。</p><p>undo log 中记录了两大类东西：</p><ul><li>MVCC 使用版本链</li><li>事务操作的逆向操作，它针对增删改记录了不同的信息： <ul><li>对于 INSERT 操作来说，它记录了完整的行，那么回滚的时候就可以根据这个行来找到被插入的数据，而后执行删除。</li><li>对于 UPDATE 来说，它记录了受影响的行修改之前的值；</li><li>对于 DELETE 来说，它记录了被删除的行的主键，删除操作在 MYSQL 执行的时候只是把数据标记为被删除，并没有真的删除，所以回滚的时候就是把这个被删除的标记位去掉。</li></ul></li></ul><p>使用 INSERT 操作时，undo log 不仅仅记录了 ID，一般是整个数据都记录下来了，只是说回滚的时候只需要 id 就可以定位到了。</p><p>使用 UPDATE 操作时，为了记录 undo log，UPDATE 执行的时候会先解析 WHERE 条件，定位到被更新的数据之后，才能记录 undo log。</p><blockquote><p>这个有点类似于我们在分布式事务里面讨论的，如果要生成反向操作，你需要先知道老的数据是什么。</p></blockquote><p>而 undo log 自身也可以看做是一个链表：</p><p><img src="'+p+'" alt="img" loading="lazy"></p><h2 id="redo-log" tabindex="-1">redo log <a class="header-anchor" href="#redo-log" aria-label="Permalink to &quot;redo log&quot;">​</a></h2><p>redo log 的主要作用是确保事务的持久性，即使在发生故障时也能保持数据库的一致性。它和 undo log 是相辅相成的，undo log 是在崩溃的时候回滚，而 redo log 是在崩溃的时候重新执行事务。</p><p>所以用 undo log 回滚还是用 redo log 重做事务，就取决于事务有没有被提交。</p><p>你可能很难理解，就是为什么事务提交了，数据库崩溃了，还要用 redo log 来重做事务。这其实有一个点：事务修改数据只是修改 buffer pool，后续再异步的刷新到磁盘上。也就是说当你的业务收到 COMMIT 成功的响应的时候，数据可能还在磁盘上。</p><p><img src="'+d+'" alt="img" loading="lazy"></p><p>这个时候就有一个时间差了，我事务提交了，但是我还没修改磁盘上上的数据，这不就是寄了吗？因此 redo log 就是为了解决这个问题的。因此在修改数据的时候，其实是先写 redo log，再修改 buffer pool。</p><p>这时候你就有疑问了，干嘛不直接写磁盘，又写 redo log，又写 buffer pool 的。这就要说到 redo log 的特性了，redo log 本身是一种 WAL（Write-Ahead Log），也就是顺序写的日志，只追加不修改。所以它的性能非常好，极快。</p><p>相当于，如果你直接修改磁盘上的数据，那就是随机写；但是你写 redo log，那就是顺序写。而众所周知，顺序写比随机写快多了。</p><p>但是这又会有一个问题，redo log 最开始是写到了 redo log buffer 上，而你 redo log 也得刷盘啊。</p><p>这个刷盘行为由 innodb_flush_log_at_trx_commit 来控制：</p><ul><li>0：每秒刷新到磁盘，是从 redo log buffer 到磁盘。</li><li>1：每次提交的时候刷新到磁盘上，也就是最安全的选项，InnoDB 的<strong>默认值</strong>。</li><li>2：每次提交的时候刷新到 page cache 里，依赖于操作系统后续刷新到磁盘。而操作系统什么时候刷，就不知道了；</li></ul><p>因此很显然，这就有一个问题：如果要是用了参数 0 和 2，那么你业务收到提交成功的时候，redo log 都还在磁盘上，如果此时宕机，一样会丢掉数据。类似的，参数是 2 也会有问题。</p><h2 id="mysql-锁" tabindex="-1">Mysql 锁 <a class="header-anchor" href="#mysql-锁" aria-label="Permalink to &quot;Mysql 锁&quot;">​</a></h2><p>MYSQL 的锁机制，有很多角度可以回答:</p><ul><li>行锁与表锁：是锁住行还是锁住表；</li><li>共享锁与排它锁：这是指一个人加了锁之后，另外一个人还能不能加锁；</li><li>意向锁：就是想加锁，但是没加锁的意向；</li><li>记录锁、临键锁和间隙锁：这有点类似行锁还是表锁，描述的是锁的范围，但是这个更加详细： <ul><li>记录锁：锁住特定的行</li><li>间隙锁：锁住行之间的间隙</li><li>临键锁：next-key lock，不管是英文名还是中文译名都很难理解，简单说，记录锁 + 间隙锁合并在一起就是临键锁了</li></ul></li></ul><p>而后你要记得提起一个点，就是如果在查询中查询没有命中任何索引，那么就会使用表锁。这种情况下，性能衰减非常可怕。</p><p>同时也要表达自己的态度，即优先考虑使用乐观锁，并且如果你有使用乐观锁来优化悲观锁的案例，也可以顺便提及。</p><p>另外一个就是隔离级别和锁的关系的问题，这主要影响的是临键锁和间隙锁，这两种锁只工作在可重复读这个隔离级别下。</p><p>不建议在数据库中直接使用 SELECT FOR UPDATE 之类的这种悲观锁，而是更加倾向于使用乐观锁。通过使用乐观锁来优化了很多 SELECT FOR UPDATE 的这种写法，一方面提高了性能，一方面也规避了死锁等问题。</p><p>同时应该把隔离级别调整到已提交读上，这样可以减少 MYSQL 使用锁。例如说间隙锁和临键锁就是工作在可重复读这个隔离级别的。通常我们说已提交读的性能会更好，也有锁这个原因。</p><h3 id="记录锁、临键锁和间隙锁" tabindex="-1">记录锁、临键锁和间隙锁 <a class="header-anchor" href="#记录锁、临键锁和间隙锁" aria-label="Permalink to &quot;记录锁、临键锁和间隙锁&quot;">​</a></h3><ol><li>记录锁：首先记录锁针对的是一条条的数据，例如说在使用等值查询的时候，一般加的就是记录锁。</li><li>隙锁针：对的是某一个范围，但是间隙锁一般不包含端点。</li><li>临键锁：可以看做是记录锁和间隙锁的结合。</li></ol><p>具体什么时候加什么锁，是比较复杂的，但是我有一个简单的原则可以快速判定：等值查询记录锁，范围查询间隙锁，端点存在临键锁。</p>',66)]))}const q=o(r,[["render",t]]);export{b as __pageData,q as default};
