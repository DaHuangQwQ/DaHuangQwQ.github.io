import{_ as s,c as i,o as a,V as l}from"./chunks/framework.WykxUCM3.js";const n="/assets/mysqljob1.p2UBmQPf.png",t="/assets/mysqljob2.JP3GVobo.png",y=JSON.parse('{"title":"分布式任务调度系统","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/go/分布式任务调度系统.md","filePath":"labnote/go/分布式任务调度系统.md"}'),e={name:"labnote/go/分布式任务调度系统.md"},h=l('<h1 id="分布式任务调度系统" tabindex="-1">分布式任务调度系统 <a class="header-anchor" href="#分布式任务调度系统" aria-label="Permalink to &quot;分布式任务调度系统&quot;">​</a></h1><h2 id="分布式锁方案" tabindex="-1">分布式锁方案 <a class="header-anchor" href="#分布式锁方案" aria-label="Permalink to &quot;分布式锁方案&quot;">​</a></h2><blockquote><p>如果抢到了分布式锁，那么就执行任务，否在就不执行</p></blockquote><p>基于 redis 实现的分布式锁</p><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><p>只能控制住同一时刻只有一个 goroutine 在计算热榜，但是控制不住计算一次之后，别的机器就不要去计算热榜了</p><h3 id="如何解决缺点" tabindex="-1">如何解决缺点 <a class="header-anchor" href="#如何解决缺点" aria-label="Permalink to &quot;如何解决缺点&quot;">​</a></h3><p>当下的分布式锁的意思是，我只在计算的过程中持有这个锁，等计算完毕我就释放锁。</p><p>我们可以考虑在启动的时候拿到锁，而后不管计算几次，都不会释放锁</p><p>自己拿到了锁，那么就要开启自动续约功能</p><h2 id="基于-mysql-的分布式任务调度" tabindex="-1">基于 mysql 的分布式任务调度 <a class="header-anchor" href="#基于-mysql-的分布式任务调度" aria-label="Permalink to &quot;基于 mysql 的分布式任务调度&quot;">​</a></h2><h3 id="两种形态" tabindex="-1">两种形态 <a class="header-anchor" href="#两种形态" aria-label="Permalink to &quot;两种形态&quot;">​</a></h3><ul><li>SDK 形态</li><li>调度中心形态</li><li>同时支持两种形态</li></ul><h3 id="负载均衡" tabindex="-1">负载均衡 <a class="header-anchor" href="#负载均衡" aria-label="Permalink to &quot;负载均衡&quot;">​</a></h3><h4 id="调度节点" tabindex="-1"><strong>调度节点</strong> <a class="header-anchor" href="#调度节点" aria-label="Permalink to &quot;**调度节点**&quot;">​</a></h4><p><img src="'+n+'" alt="mysqljob1" loading="lazy"></p><p><img src="'+t+`" alt="mysqljob1" loading="lazy"></p><h4 id="执行节点" tabindex="-1"><strong>执行节点</strong> <a class="header-anchor" href="#执行节点" aria-label="Permalink to &quot;**执行节点**&quot;">​</a></h4><ul><li>普通的客户端负载均衡算法都可以用</li><li>维护一个客户端节点正在执行任务数量 —— 对应于微服务负载均衡中的活跃请求数负载均衡</li></ul><h3 id="长时间执行任务的进度探查与上报" tabindex="-1"><strong>长时间执行任务的进度探查与上报</strong> <a class="header-anchor" href="#长时间执行任务的进度探查与上报" aria-label="Permalink to &quot;**长时间执行任务的进度探查与上报**&quot;">​</a></h3><ul><li>比如说处理 1000w 条数据</li><li>执行时间要个几十分钟</li></ul><h4 id="关键点" tabindex="-1"><strong>关键点</strong> <a class="header-anchor" href="#关键点" aria-label="Permalink to &quot;**关键点**&quot;">​</a></h4><ul><li>调度中心开始调度，执行节点只会返回一个 Accepted 的响应，意思就是我正在执行。</li><li>两个选择： <ul><li>调度中心主动探查 <ul><li>同样用 HTTP 接口或者 RPC 接口来探查 <ul><li>例如 HTTP 接口 POST POST /a/b/most_fans 方法，就是启动新任务</li><li>GET /a/b/most_fans 就是拿执行进度</li><li>GET /a/b/all_tasks 拿到当前节点所有执行中任务</li></ul></li><li>一种优化措施：就是每个执行节点至多有一个 TCP 连接，专门用来传递进度</li></ul></li><li>执行节点主动上报 <ul><li>调度节点暴露 HTTP 接口或者 RPC 接口 <ul><li>执行节点 POST /a/b/task_progress execution_id: 123, progress: 50%</li></ul></li><li><strong>调度节点提供一个 消息队列和对应的 Topic</strong>。 <ul><li>执行节点发送消息 execution_id: 123, progress: 50% 到 Topic 上</li><li>调度节点消费消息</li></ul></li></ul></li></ul></li></ul><h3 id="中断与再均衡" tabindex="-1">中断与再均衡 <a class="header-anchor" href="#中断与再均衡" aria-label="Permalink to &quot;中断与再均衡&quot;">​</a></h3><h4 id="调度节点的再均衡问题" tabindex="-1"><strong>调度节点的再均衡问题</strong> <a class="header-anchor" href="#调度节点的再均衡问题" aria-label="Permalink to &quot;**调度节点的再均衡问题**&quot;">​</a></h4><p>一般不考虑。</p><h4 id="执行节点中断与再均衡问题" tabindex="-1"><strong>执行节点中断与再均衡问题</strong> <a class="header-anchor" href="#执行节点中断与再均衡问题" aria-label="Permalink to &quot;**执行节点中断与再均衡问题**&quot;">​</a></h4><ul><li>要在上报进度的时候，执行节点要上报自己的进度，负载，以及是否重调度，和重调度的参数。举个例子：{progress: 50%, rebalance: true, params: {offset: 10w} }</li><li>调度节点收集到进度信息，选择其它执行节点，带上 params，要求执行节点继续执行</li></ul><h3 id="任务编排" tabindex="-1">任务编排 <a class="header-anchor" href="#任务编排" aria-label="Permalink to &quot;任务编排&quot;">​</a></h3><ul><li>调度节点上，维持住一个有向图</li><li>每次收到任务执行完毕的信息，就检查这个有向图，确定下一个任务</li></ul><h3 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-label="Permalink to &quot;思路&quot;">​</a></h3><ul><li>在数据库中创建一张表，里面是等待运行的定时任务</li><li>所有的实例都试着从这个表里面“抢占”等待运行的任务，抢占到了就执行</li></ul><blockquote><p>抢占的时候我崩了怎么办？</p><p>答：引入续约机制</p><p>怎么表达一个抢占动作？</p><p>答：使用乐观锁更新状态，也就是我先找到符合条件的记录，然后我尝试更新状态为调度中，为了防止并发竞争，我用 version来保证在我读取，到我更新的时候，没有人抢占了它</p></blockquote><h3 id="表结构设计" tabindex="-1">表结构设计 <a class="header-anchor" href="#表结构设计" aria-label="Permalink to &quot;表结构设计&quot;">​</a></h3><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Job</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Id       </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int64</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`gorm:&quot;primary_key,AUTO_INCREMENT&quot;\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Cfg      </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Name     </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`gorm:&quot;unique&quot;\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Status   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Version  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int64</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Cron     </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	NextTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int64</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`gorm:&quot;index&quot;\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	UTime    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int64</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	CTime    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int64</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="优化策略" tabindex="-1">优化策略 <a class="header-anchor" href="#优化策略" aria-label="Permalink to &quot;优化策略&quot;">​</a></h3><ol><li>一次取一批， 一次性取出100个，然后随机从某一条开始抢占</li><li>随机偏移量，兜底：第一次没查到，偏移量回归到 0</li><li>id取余分配， 兜底不加余数条件</li><li>乐观锁 CAS操作，compare and swap</li><li>用乐观锁 取代 for update（性能差，死锁）</li></ol><h2 id="基于-k8s-的分布式任务调度" tabindex="-1">基于 k8s 的分布式任务调度 <a class="header-anchor" href="#基于-k8s-的分布式任务调度" aria-label="Permalink to &quot;基于 k8s 的分布式任务调度&quot;">​</a></h2><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">batch/v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">CronJob</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">webook</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  jobTemplate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">        spec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          containers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            - </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">hello-world</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">              image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">flycash/cron_job:v0.0.1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">              imagePullPolicy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">IfNotPresent</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">          restartPolicy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">OnFailure</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*/5 * * * *&quot;</span></span></code></pre></div><h2 id="分布式任务调度平台" tabindex="-1">分布式任务调度平台 <a class="header-anchor" href="#分布式任务调度平台" aria-label="Permalink to &quot;分布式任务调度平台&quot;">​</a></h2><ol><li>加入部门管理和权限控制功能</li><li>加入 HTTP 任务和 GRPC 任务支持（也就是调度一个任务，就是调用一个 HTTP 接口，或者调用一个GRPC 接口）</li><li>加入任务执行历史的功能（也就是记录任务的每一次执行情况）</li></ol>`,41),p=[h];function r(k,o,d,E,c,g){return a(),i("div",null,p)}const b=s(e,[["render",r]]);export{y as __pageData,b as default};
