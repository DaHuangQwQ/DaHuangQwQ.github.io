import{_ as e,c as l,a2 as p,o as n}from"./chunks/framework.BQmytedh.js";const c="/assets/a23b232b-d645-44a6-888d-dcb8e71da80c.drOt24ON.png",t="/assets/5175338f-4c8c-4518-8199-7e54f8fd9b8b.BhE0CMJ9.png",m="/assets/a0371891-c395-4ee1-918a-4531b112db79.BAHlIR0k.png",i="/assets/9e3c1fdb-9adb-4672-8661-50574444a84c.D8IVQLcn.png",B=JSON.parse('{"title":"golang","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/go/golang.md","filePath":"labnote/go/golang.md"}'),o={name:"labnote/go/golang.md"};function s(r,a,h,g,d,u){return n(),l("div",null,a[0]||(a[0]=[p('<h1 id="golang" tabindex="-1">golang <a class="header-anchor" href="#golang" aria-label="Permalink to &quot;golang&quot;">​</a></h1><h2 id="gmp" tabindex="-1">GMP <a class="header-anchor" href="#gmp" aria-label="Permalink to &quot;GMP&quot;">​</a></h2><h2 id="内存分配" tabindex="-1">内存分配 <a class="header-anchor" href="#内存分配" aria-label="Permalink to &quot;内存分配&quot;">​</a></h2><p>与 Linux 的 SLAB 进行对比，两者都是分层结构，而且都是局部缓存-全局缓存这种结构，和 Go 的 GMP 调度的局部队列-全局队列的思路也是一致的，用引入局部数据结构来降低全局竞争</p><p>Go 堆上分配有三个核心结构：</p><ul><li>mcache：这个是和 P 绑定的，看到这个你就知道它是和并发没有什么关系的，是 P 自己独占的；</li><li>mcentral：是所有的 P 共享的。</li><li>mheap：也是所有的 P 共享的，但是一般我们会说它管理的是内存大块是 Areana（注意 Go 的堆外内存实验特性也叫做 Arena）。它和 mcentral 的区别在两方面：它是和操作系统打交道的，负责从操作系统里面申请内存；它还要和垃圾回收打交道，或者说垃圾回收是通过 mheap 来进行的。</li></ul><p>一看这种三级结构，你就应该大概猜到分配内存的过程：</p><ul><li>优先从 mcache 分配一块空闲内存给应用；</li><li>如果 mcache 没有空闲内存了，那么从 mcentral 里面拿一块大内存，而后分配一块小的给应用；</li><li>如果 mcentral 也没有空闲内存了，那么就从 mheap 拿一块内存，再分配给 mcache，最终 mcache 分配给应用；</li></ul><p>那么在这里有一个要注意的点，就是内存管理不是说随便管的，mcache、mcentral 和 mheap 都是按照 span 来管的，也叫做 mspan。那么这个 mspan 是什么东西呢？</p><p>mspan 是一块连续内存，一般由多个页组成，例如说 8KB（2页）一个 mspan。mspan 内部被进一步分配成了固定大小的对象，比如说 64B 一个对象。</p><p>那么不同对象大小的 mspan 就相当于有一些是 200 张 50 块的一捆，或者 1000 张 10 块的一捆，又或者 100 张 100 块的一捆。因此大体上结构如下图：</p><p><img src="'+c+'" alt="img" loading="lazy"></p><p>上面不同颜色代表 span 里面对象大小是不同的。比如说你可以认为绿色代表的是 100 块的一捆一万块，蓝色的是 50 块的一捆一万块。</p><p>当然，你稍微一想也能知道，最好的管理 span 的方式，就是按照对象大小把这些 span 串联在一起。相当于，50 一捆的放一个库房，100 一捆的放一个库房，这样好管理，好分配。</p><p>因此，实际上 mcache 里面的 span 组织方式是这样的：</p><p><img src="'+t+'" alt="img" loading="lazy"></p><p>而 mcentral 有点特殊，因为它放着很多 span，所以它把 span 分成了满（full）和不满（partial）两个部分。对应的结构是：</p><p><img src="'+m+'" alt="img" loading="lazy"></p><blockquote><p>有些人也叫做 empty 和 not empty</p></blockquote><p>所以当 mcache 从 mcentral 里面去拿 span 的时候，就是从 partial 里面拿一个。</p><p>而 Go 会使用位图（bitmap）来标记每个 span 内部的对象有没有被使用过。如下图是一个简单的实例：</p><p><img src="'+i+'" alt="img" loading="lazy"></p><p>因此，假设说现在我们需要一个 24B 大小的内存，或者说我们的一个 struct 要占据 24B，那么：</p><ul><li>mcache 看看自己的 32B 对象大小的 span 链表里面能不能找到一个空闲的对象，如果能，则直接返回；</li><li>mcache 发现自己没有，就去找 mcentral 要一个放 32B 对象的 span，mcache 拿到之后，就给我们一个空闲对象；</li><li>如果 mcentral 也没有，就去找 mheap 要一个放 32B 对象的 span；</li><li>如果 mheap 也没有，就会去找操作系统要一个 arena，然后切割成 span，将其中的一个给 mcentral；</li></ul><p>那么最后还有一个问题，你从上面这个流程里面就能发现，如果我对象只有 4B，难道也是给我一个 32B 的对象吗？那不就是浪费了 28B？而且，绝对部分对象都是小对象，都是很小的对象。比如说只有一两个，两三个字段的结构体，32B 都用不完。岂不是浪费很多？</p><p>所以 Go 在 mcache 里面搞了一个小东西，叫做极小对象（tiny object）分配，极小对象也是分配在堆上的，只是它针对的是小于 16B 的非指针对象（指针对象还是走上面的 mcache-mcentral-mheap 的路径）。</p><p>最后总结：</p><ul><li>极小对象：小于 16B 的 no scan（没有指针）对象，专门走 tiny object 的逻辑，直接分配到堆上；</li><li>小对象：16B ~ 32KB 的指针对象，小于 16B 的 scan （有指针）对象，走 mcache-mcentral-mheap 这条路；</li><li>大对象：大于 32KB 的对象，直接在 mheap 上分配；</li></ul><blockquote><p>极小对象，专门分配；小对象，走三关；大对象，mheap；</p></blockquote><p>极小对象的分配</p><ul><li>如果这个对象没有发生逃逸，那么就是栈上分配；</li><li>如果这个对象逃逸了，但是它是 no scan（没有指针） 对象，那么就会使用极小对象分配器，直接分配到特定的极小对象内存区域；</li><li>如果这个对象逃逸了，但是它不是 no scan（没有指针） 对象，那么就如同普通对象一样，经过 mcache-mcentral-mheap 这个机制分配；</li></ul><h3 id="流程" tabindex="-1">流程 <a class="header-anchor" href="#流程" aria-label="Permalink to &quot;流程&quot;">​</a></h3><p>Go 的内存分配分成了栈上分配和堆上分配两种。</p><p>栈上分配也就是分配到 goroutine 的栈上，这个过程是通过编译器在编译期间计算好如何分配的。</p><p>但是如果在编译期间，编译器发现没有办法分配到栈上，那么就会分配到堆上，这也就是所谓的内存逃逸。这个时候，运行时要根据对象大小来判定执行哪一种分配：</p><ul><li>如果是极小对象，也就是小于 16B 的非指针对象，那么就会直接利用极小对象分配器，分配到堆上</li><li>如果是大对象，也就是大于 32KB 的对象，那么就会直接分配到 mheap 上</li><li>否则，就按照 mcache、 mcentral 和 mheap 的三级结构，找到一个合适的 span 里面的空闲对象，分配给应用</li></ul><p>举个例子来说，假设说现在应用需要 24B 内存，那么它就会首先找 mcache，mcache 从自己的 32B 的 span 里面找一个空闲的对象，交给应用。</p><p>如果 mcache 没有，那么就找 mcentral 里面要一个 span。mcentral 会从自己的 pratial（不满的） 的 span 里面找出一个给 mcache，mcache 再找出一个空闲对象给应用。</p><p>如果 mcentral 也没有合适的 span，它就会找 mheap 要一个 span。</p><p>如果 mheap 也没有合适的 span，它就会找操作系统要一块 arena，自己切割成 span，交给 mcentral 一块span，而后 mcentral 再给 mcache，mcache 再找空闲对象给应用。</p><h2 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h2>',41)]))}const f=e(o,[["render",s]]);export{B as __pageData,f as default};
