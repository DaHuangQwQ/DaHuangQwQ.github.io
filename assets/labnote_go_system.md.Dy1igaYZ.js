import{_ as i,c as e,a2 as t,o as u}from"./chunks/framework.BQmytedh.js";const h=JSON.parse('{"title":"系统设计","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/go/system.md","filePath":"labnote/go/system.md"}'),a={name:"labnote/go/system.md"};function s(o,l,r,n,d,c){return u(),e("div",null,l[0]||(l[0]=[t('<h1 id="系统设计" tabindex="-1">系统设计 <a class="header-anchor" href="#系统设计" aria-label="Permalink to &quot;系统设计&quot;">​</a></h1><h2 id="短链系统" tabindex="-1">短链系统 <a class="header-anchor" href="#短链系统" aria-label="Permalink to &quot;短链系统&quot;">​</a></h2><ul><li>生成过程 <ul><li>分布式 ID 生成（分库分表）： <ul><li>集中式发号器： <ul><li>批量取</li><li>预先取</li></ul></li><li>服务本身作为雪花算法 ID <ul><li>唯一的难点就是要给服务节点分配机器 ID 号：最简单就是配置文件</li><li>走 Redis 就是很多公司用的</li></ul></li></ul></li><li>一个长链： <ul><li>有多个短链：用在没必要去重的情况下</li><li>只有一个短链 <ul><li>Redis 反向映射关系（长链到短链），保证在一段时间内不会重复生成就可以。（Redis 使用独立集群）</li></ul></li></ul></li><li>具有有效期的短链，归档减少数据量 <ul><li>特定业务，我会监听事件，然后删除短链</li><li>每天归档，根据有效期挪走，设置一个标记位</li></ul></li><li>分库分表设计 <ul><li>相当于按照日期分了: <ul><li>64 位数字 &lt;=&gt; 62 进制的编码</li><li>64 位中的 41 比特是时间戳 =&gt; 它的创建时间</li></ul></li><li>按照 ID 哈希分：</li></ul></li><li>生成限流，几千</li></ul></li><li>访问过程 <ul><li>本地缓存 + Redis 缓存 <ul><li>前缀树 手搓 本地缓存，提高内存使用率</li><li>结合哈希类负载均衡算法 + 本地缓存</li><li>提前加载到本地缓存，永不过期 <ul><li>只加载热点 =&gt; 从访问日志捞过来</li><li>大博主的短链</li></ul></li></ul></li><li>存在性检测： <ul><li>短链 =&gt; 分布式 ID，你就可以做初步检测了。这一步就能挡住绝大多数的错误短链 <ul><li>时间范围</li><li>机器 ID 不对的话的也不对</li></ul></li><li>布隆过滤器： <ul><li>分 key 布隆过滤器，每个月一个布隆过滤器 =&gt; 每个月的数据，我是不是只需要这个月的表扫一遍；</li></ul></li></ul></li></ul></li><li>多域名的短链系统 <ul><li>通过域名来分发到多个不同的集群，实现超高并发的最外层的流量分发</li></ul></li><li>服务治理 <ul><li>隔离：读服务、写服务分离（客户端负载均衡 + 注册中心）</li><li>降级： <ul><li>如果要是资源不足，可以直接拒绝写请求</li><li>Redis 缓存或者 MySQL 崩溃，都可以尝试继续服务</li><li>快速失败的降级策略：最多读到 Redis。</li><li>singleflight</li></ul></li></ul></li><li>冷热分离（可以考虑）：读写集群分离，高性价比 <ul><li>近期生成的就是热的（本地缓存 + Redis + MySQL），应该确保至少在 Redis 里面就能找到，使用独立的集群</li><li>不远不近的就是温的（Redis），尽量放 Redis 里面，可使用独立的集群</li><li>生成很久的就是冷的，直接走 MySQL，做好限流</li></ul></li><li>OpenRestry（正在调研要不要转到 OpenRestry上）</li></ul>',3)]))}const p=i(a,[["render",s]]);export{h as __pageData,p as default};
