import{_ as d,c as t,a2 as e,o as c}from"./chunks/framework.BQmytedh.js";const a="/assets/automaton.Dru8CEyo.png",m=JSON.parse('{"title":"Automaton","description":"","frontmatter":{},"headers":[],"relativePath":"system/compiler/automaton.md","filePath":"system/compiler/automaton.md"}'),r={name:"system/compiler/automaton.md"};function l(n,o,i,s,h,u){return c(),t("div",null,o[0]||(o[0]=[e('<h1 id="automaton" tabindex="-1">Automaton <a class="header-anchor" href="#automaton" aria-label="Permalink to &quot;Automaton&quot;">​</a></h1><blockquote><p>RE 正则表达式</p><p>NFA 非确定性有限自动机 简洁易于理解</p><p>DFA 确定性有限自动机 易于判断，适合产生词法分析器</p></blockquote><p><img src="'+a+'" alt="automaton" loading="lazy"></p><h2 id="re-正则表达式" tabindex="-1">RE 正则表达式 <a class="header-anchor" href="#re-正则表达式" aria-label="Permalink to &quot;RE 正则表达式&quot;">​</a></h2><table tabindex="0"><thead><tr><th>表达式</th><th>匹配描述</th><th>例子</th></tr></thead><tbody><tr><td><code>c</code></td><td>单个非运算符字符 <code>c</code></td><td><code>a</code></td></tr><tr><td><code>\\c</code></td><td>字符 <code>c</code> 的字面值</td><td><code>\\*</code></td></tr><tr><td><code>&quot;s&quot;</code></td><td>字符串 <code>s</code> 的字面值</td><td><code>&quot;**&quot;</code></td></tr><tr><td><code>.</code></td><td>除换行符以外的任何字符</td><td><code>a.*b</code></td></tr><tr><td><code>^</code></td><td>一行的开始</td><td><code>^abc</code></td></tr><tr><td><code>$</code></td><td>行的结尾</td><td><code>abc$</code></td></tr><tr><td><code>[s]</code></td><td>字符串 <code>s</code> 中的任意一个字符</td><td><code>[abc]</code></td></tr><tr><td><code>[^s]</code></td><td>不在字符串 <code>s</code> 中的任意一个字符</td><td><code>[^abc]</code></td></tr><tr><td><code>r*</code></td><td>和 <code>r</code> 匹配的零个或多个连续接成的串</td><td><code>a*</code></td></tr><tr><td><code>r+</code></td><td>和 <code>r</code> 匹配的一个或多个连续接成的串</td><td><code>a+</code></td></tr><tr><td><code>r?</code></td><td>零个或一个 <code>r</code></td><td><code>a?</code></td></tr><tr><td><code>r{m,n}</code></td><td>最少 <code>m</code> 个，最多 <code>n</code> 个 <code>r</code> 的重复出现</td><td><code>a{1,5}</code></td></tr><tr><td><code>r1r2</code></td><td><code>r1</code> 后加上 <code>r2</code></td><td><code>ab</code></td></tr><tr><td>`r1</td><td>r2`</td><td><code>r1</code> 或 <code>r2</code></td></tr><tr><td><code>(r)</code></td><td>与 <code>r</code> 相同</td><td>`(a</td></tr><tr><td><code>r1/r2</code></td><td>后面跟有 <code>r2</code> 时的 <code>r1</code></td><td><code>abc/123</code></td></tr></tbody></table><h2 id="thompson-构造法" tabindex="-1">Thompson 构造法 <a class="header-anchor" href="#thompson-构造法" aria-label="Permalink to &quot;Thompson 构造法&quot;">​</a></h2><h3 id="thompson构造法的基本思想" tabindex="-1">Thompson构造法的基本思想 <a class="header-anchor" href="#thompson构造法的基本思想" aria-label="Permalink to &quot;Thompson构造法的基本思想&quot;">​</a></h3><p>Thompson构造法通过<strong>构建简单的NFA单元</strong>，然后将这些单元根据正则表达式的操作（如连接、并、闭包）组合成一个完整的NFA。这个NFA能够接受正则表达式所描述的所有字符串。</p><p>以下是该构造法的基本单元及其组合方式：</p><ol><li><p>基本单元</p><ul><li><strong>空字符串 ε</strong>：用两个状态（起始状态和终止状态）表示，从起始状态到终止状态通过 ε 转移。</li><li><strong>单字符 a</strong>：用两个状态表示，从起始状态到终止状态通过字符<code>a</code>转移。</li></ul></li><li><p>组合规则</p><ul><li><p><strong>连接（Concatenation）</strong>：如果要构建 <code>A·B</code>，可以将 <code>A</code> 的终止状态与 <code>B</code> 的起始状态通过 ε 转移相连。</p></li><li><p><strong>并（Union/Alternation）</strong>：对于 <code>A | B</code>，构造一个新的起始状态和终止状态，从新的起始状态通过 ε 转移连接到 <code>A</code> 和 <code>B</code> 的起始状态，再从 <code>A</code> 和 <code>B</code> 的终止状态通过 ε 转移连接到新的终止状态。</p></li><li><p>闭包（Kleene Star）</p><p>：对 <code>A*</code>，创建新的起始和终止状态，并通过 ε 转移连接：</p><ul><li>从新的起始状态到<code>A</code>的起始状态。</li><li>从<code>A</code>的终止状态返回到<code>A</code>的起始状态（形成循环）。</li><li>从新的起始状态直接到新的终止状态（表示空串）。</li><li>从<code>A</code>的终止状态到新的终止状态。</li></ul></li></ul></li></ol><h3 id="具体步骤" tabindex="-1">具体步骤 <a class="header-anchor" href="#具体步骤" aria-label="Permalink to &quot;具体步骤&quot;">​</a></h3><p>为了更好地理解Thompson构造法的具体操作步骤，假设我们有一个简单的正则表达式 <code>a(b|c)*</code>。我们通过以下步骤构造其NFA：</p><ol><li><strong>构建基本单元</strong>： <ul><li>构建字符<code>a</code>的NFA单元。</li><li>构建字符<code>b</code>和字符<code>c</code>的NFA单元。</li></ul></li><li><strong>构建并（Union）操作</strong>： <ul><li>使用并操作构建 <code>b|c</code> 的NFA，即创建一个新的起始状态连接到<code>b</code>和<code>c</code>的起始状态，也创建新的终止状态从<code>b</code>和<code>c</code>的终止状态出发。</li></ul></li><li><strong>构建闭包（Star）操作</strong>： <ul><li>使用闭包操作对 <code>b|c</code> 进行星闭包构建，即创建新的起始状态和新的终止状态，通过ε转移实现循环结构，确保重复匹配。</li></ul></li><li><strong>构建连接操作</strong>： <ul><li>将字符<code>a</code>的NFA和 <code>(b|c)*</code> 的NFA连接在一起，形成 <code>a(b|c)*</code> 的完整NFA。</li></ul></li></ol><h3 id="构造的特点" tabindex="-1">构造的特点 <a class="header-anchor" href="#构造的特点" aria-label="Permalink to &quot;构造的特点&quot;">​</a></h3><ul><li><strong>简单直接</strong>：每种正则操作（连接、并、闭包）都有固定的构造步骤，使得实现自动化构造变得容易。</li><li><strong>非确定性</strong>：由于Thompson构造法生成的是NFA，因此可以在一个状态下有多个可能的转移，尤其是使用 ε 转移来实现不同单元的组合。</li></ul><h2 id="子集构造法" tabindex="-1">子集构造法 <a class="header-anchor" href="#子集构造法" aria-label="Permalink to &quot;子集构造法&quot;">​</a></h2><h2 id="dfa-最小化" tabindex="-1">DFA 最小化 <a class="header-anchor" href="#dfa-最小化" aria-label="Permalink to &quot;DFA 最小化&quot;">​</a></h2>',17)]))}const b=d(r,[["render",l]]);export{m as __pageData,b as default};
