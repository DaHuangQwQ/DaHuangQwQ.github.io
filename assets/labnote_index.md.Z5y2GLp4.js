import{_ as o,c as i,o as a,V as l}from"./chunks/framework.jgiY9GFO.js";const G=JSON.parse('{"title":"转 go 语言的学习之路","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/index.md","filePath":"labnote/index.md"}'),e={name:"labnote/index.md"},t=l('<h1 id="转-go-语言的学习之路" tabindex="-1">转 go 语言的学习之路 <a class="header-anchor" href="#转-go-语言的学习之路" aria-label="Permalink to &quot;转 go 语言的学习之路&quot;">​</a></h1><h2 id="与其他语言比较" tabindex="-1">与其他语言比较 <a class="header-anchor" href="#与其他语言比较" aria-label="Permalink to &quot;与其他语言比较&quot;">​</a></h2><ul><li>go 语言非常类似于 c 语言</li><li>for 循环的迭代变量都是共享地址的</li><li>go 的数组功能很弱</li><li>go 的切片是共享地址的</li><li>go 有类型推断，但是没有自动类型转换</li><li>go 的范型太弱</li><li>语法简单，支持轻量级线程（goroutine）和通信（channel），通俗的讲就是尽量避免使用系统调用，减少切换上下文的开销</li><li>函数式编程，如责任链模式和其他语言不太常见的 option 模式</li><li>错误处理，go 语言的错误处理一言难尽</li><li>go 缺乏 SPI（service provider interface）机制与动态生成新的类型的机制，导致很多特性依赖于代码生成技术，但是带来了代码易读</li><li>面试难点：内存分配 垃圾回收 GMP调度 并发编程 内置类型的实现原理</li><li>面试八古文少，go 的框架都很简单易用</li></ul><h2 id="与-java-比较" tabindex="-1">与 java 比较 <a class="header-anchor" href="#与-java-比较" aria-label="Permalink to &quot;与 java 比较&quot;">​</a></h2><ul><li>Java 使⽤⼴泛，但是 Go ⽐ Java 更适合⾼并发和轻量级的应⽤</li><li>Java 通过线程和锁来处理并发， Goroutines 和 channels 是 Go 语⾔的并发特性的核⼼</li><li>Java 是⼀⻔功能丰富、⾯向对象的语⾔，⽀持⾯向对象编程、泛型等⾼级特性。 Go 语⾔的设计注重简洁和清晰，具有简单的语法和类型系统。它摒弃了⼀些复杂的特性，强调代码的可读性。</li><li>Go没有类的概念，⽽是通过结构体（struct）和接⼝（interface）来实现⾯向对象的特性。</li><li>Go语⾔通过接⼝来定义对象的⾏为，⽽不是通过明确的继承关系。⼀个类型只要实现了接⼝定义的⽅法，就被视为实现了该接⼝。</li><li>Go语⾔通过结构体的组合特性来实现对象的组合。⼀个结构体可以包含其他结构体作为其字段，从⽽实现对象的复⽤。</li><li>GO通过⾸字⺟⼤⼩写来控制成员的可⻅性，实现了封装的效果。⾸字⺟⼤写的成员是公有的，可以被外部包访问；⾸字⺟⼩写的成是私有的，只能在定义的包内访问。</li></ul><h3 id="go-的错误处理和-java-的异常处理对比" tabindex="-1"><strong>Go</strong> <strong>的错误处理和</strong> <strong>Java</strong> <strong>的异常处理对⽐</strong> <a class="header-anchor" href="#go-的错误处理和-java-的异常处理对比" aria-label="Permalink to &quot;**Go** **的错误处理和** **Java** **的异常处理对⽐**&quot;">​</a></h3><ol><li>Go</li></ol><ul><li>Go语⾔使⽤返回值来处理错误，函数通常返回两个值，⼀个是正常的返回值，另⼀个是 error 类型的值，⽤于表示可能出现的错误。开发者需要显式地检查错误并进⾏处理，通过判断返回的 error 值是否为 nil 来确定函数是否执⾏成功。</li><li>Go中的错误是普通的值，是实现了 error 接⼝的类型。</li><li>Go的错误处理机制在性能上通常更为⾼效，因为它不会引⼊额外的控制流程（异常栈的构建和查找等）</li></ul><ol start="2"><li>Java</li></ol><ul><li>java使⽤异常机制处理错误。当出现错误时，可以通过 throw 关键字抛出异常，⽽在调⽤栈中寻找匹配的catch 块来捕获并处理异常。</li><li>Java中的异常是对象，是某个类的实例。Java的异常类型必须继承⾃ Throwable 类或其⼦类</li><li>异常处理机制可能在性能上带来⼀定开销，特别是在抛出和捕获异常的过程中。</li></ul><h2 id="go语言并发模型" tabindex="-1"><strong>Go</strong>语⾔并发模型 <a class="header-anchor" href="#go语言并发模型" aria-label="Permalink to &quot;**Go**语⾔并发模型&quot;">​</a></h2><ul><li>Go语⾔的并发模型建⽴在goroutine和channel之上。其设计理念是<strong>共享数据通过通信⽽不是通过共享来实现</strong></li><li>Goroutines 是Go中的轻量级线程，由Go运⾏时（runtime）管理。与传统线程相⽐，goroutines的创建和销毁开销很⼩。程序可以同时运⾏多个goroutines，它们共享相同的地址空间。</li><li>Goroutines之间的通信通过channel（通道）实现。通道提供了⼀种安全、同步的⽅式，⽤于在goroutines之间传递数据。使⽤通道可以避免多个goroutines同时访问共享数据⽽导致竞态条件的问题。</li><li>多路复⽤： select 语句允许在多个通道操作中选择⼀个执⾏。这种⽅式可以有效地处理多个通道的并发操作，避免了阻塞。</li><li>goroutine（协程）是⼀种轻量级的线程，由Go运⾏时（runtime）管理，⼀个典型的 Go 程序可能会同时运⾏成千上万个 goroutine，Goroutines 使得程序可以并发执⾏，⽽⽆需显式地创建和管理线程。通过关键字 go 可以启动⼀个新的 goroutine。每个 goroutine 都有⾃⼰的独⽴栈空间，这使得它们之间的数据不容易互相⼲扰。与传统的多线程编程相⽐，使⽤goroutines 不需要开发者显式地进⾏线程的创建、销毁和同步。Go 运⾏时会⾃动处理这些事务</li><li>Channel（通道）是⽤于在goroutines之间进⾏通信的⼀种机制。通道提供了⼀种并发安全的⽅式来进⾏goroutines之间的通信。通过通道，可以避免在多个goroutines之间共享内存⽽引发的竞态条件问题，因为通道的读写是原⼦性的</li></ul><h2 id="我的看法" tabindex="-1">我的看法 <a class="header-anchor" href="#我的看法" aria-label="Permalink to &quot;我的看法&quot;">​</a></h2><p>对于中级工程师及以上，编程语言的差距没有那么大，设计实现上大多数都是一个套路</p>',14),r=[t];function n(s,u,g,h,c,d){return a(),i("div",null,r)}const v=o(e,[["render",n]]);export{G as __pageData,v as default};
