import{_ as e,c as a,a2 as r,o as l}from"./chunks/framework.BQmytedh.js";const P=JSON.parse('{"title":"TCP外的拥塞控制","description":"","frontmatter":{},"headers":[],"relativePath":"system/tcp/other.md","filePath":"system/tcp/other.md"}'),o={name:"system/tcp/other.md"};function d(i,t,T,n,C,c){return l(),a("div",null,t[0]||(t[0]=[r('<h1 id="tcp外的拥塞控制" tabindex="-1">TCP外的拥塞控制 <a class="header-anchor" href="#tcp外的拥塞控制" aria-label="Permalink to &quot;TCP外的拥塞控制&quot;">​</a></h1><p>随着拥塞控制研究的持续深入，出现了很多新的算法和协议。其中有一部分算法协议只关注特定的用户场景，而不是像TCP一样关注任意复杂度和任意异构的网络环境。这里可能有个例外是QUIC，QUIC最开始只用来提升HTTP的性能，但是现在已经被开发成了一个通用的TCP替代方案。</p><ul><li>为数据中心优化TCP性能；</li><li>将背景流量的发送时间拉长以仅仅使用富余的容量；</li><li>优化基于HTTP的web流量，同时不用兼容TCP；</li><li>以TCP友好的方式支持实时流；</li><li>支持多路径的传输协议；</li><li>以独特的radio-induced行为，更好的工作在移动蜂窝网</li></ul><h2 id="datacenters-dctcp-on-ramp" tabindex="-1">Datacenters (DCTCP, On-Ramp) <a class="header-anchor" href="#datacenters-dctcp-on-ramp" aria-label="Permalink to &quot;Datacenters (DCTCP, On-Ramp)&quot;">​</a></h2><h2 id="background-transport-ledbat" tabindex="-1">Background Transport (LEDBAT) <a class="header-anchor" href="#background-transport-ledbat" aria-label="Permalink to &quot;Background Transport (LEDBAT)&quot;">​</a></h2><h2 id="http性能提升-quic" tabindex="-1">HTTP性能提升（QUIC） <a class="header-anchor" href="#http性能提升-quic" aria-label="Permalink to &quot;HTTP性能提升（QUIC）&quot;">​</a></h2><p>随着1990年World Wide Web的发明，HTTP就一直存在，且一直运行在TCP之上。最早的 HTTP 版本是HTTP/1.0，因为其使用TCP的方式不当，有着很多性能问题，例如，每次请求一个对象都需要建立一个新的TCP连接，当收到返回之后又要关闭连接。随后提出的HTTP/1.1旨在更好的利用TCP。TCP在HTTP提出的20多年时间里持续作为其底层协议。</p><p>实际上，使用TCP来支持Web一直以来都是有问题的，尤其是一个可靠的顺序字节流并不完全是Web流量的模型。具体来说，因为大部分web页面包含了大量的对象（注，例如图片，html，css等），合理的方式应该是同时并发请求多个对象，但是TCP只提供了一个字节流。如果丢了一个包，TCP会等待其重传成功，之后再继续传输，而HTTP更乐于不受这一个丢包的影响，而继续接受其他不受这个丢包影响的对象。同时开多个TCP连接明显可以是个解决方案，但又有不能在多个连接之间共享拥塞信息的缺点。</p><p>其他的一些导致 TCP 减分的因素还包括：</p><ul><li>高延时无线网络的广泛使用</li><li>单个设备使用多个网络（例如WiFI和蜂窝网）</li><li>Web上越来越多的加密和认证连接</li></ul><p>这一切使得人们认识到，HTTP最好使用一个新的传输层，而填补这个空白的协议就是QUIC。</p><p>QUIC于2012年起源于Google，随后被作为一个标准在IETF研究。目前已经可以看到大量的部署，大部分Web浏览器和很多主流的网站已经在使用QUIC，甚至在一些非HTTP的应用程序中也开始使用QUIC。可部署性是QUIC开发人员的一个关键考量。QUIC有很多复杂的部分——它的规范跨越了数百页的三个RFC，但我们在这里只关注它的拥塞控制方法，它融合了我们在本书中迄今为止看到的许多想法。</p><ul><li>与TCP一样，QUIC在数据的传输过程中实现拥塞控制，但是它也意识到没有完美的拥塞控制算法。所以，它也<strong>允许不同的发送端可以使用不同的拥塞控制算法</strong>。QUIC规范中的基本算法类似于TCP NewReno，但是发送端可以单方面的选择一个不同的算法，例如CUBIC。QUIC提供了可以用来探测丢包的所有机制，以供各种拥塞算法使用。</li><li>QUIC包含了很多设计使得丢包和拥塞的探测比TCP更加的健壮。例如，TCP一个packet不管它是第一次传输还是重传，都是用相同的序列号，而QUIC的序列号（叫做packet numbers）是严格递增的。更高的packet number表明packet更晚被发送，而更小的packet number表明packet更早被发送。这意味着总是能够区分一个packet究竟是第一次传输还是因为丢包或者超时而重传。</li><li>TCP的序列号指的是字节数，而QUIC的packet number直接表示的就是packet数量。QUIC的packet number空间很大，有61bit，所以不会像TCP的序列号一样溢出。</li><li>QUIC协议内置了选择性确认（selective ACK），且比TCP的SACK option中最多支持确认3段数据更多。这提升了在高丢包环境的性能，因为只要部分packet被成功收到了，传输就能够继续。</li><li>相比TCP快速重传中的重复ACK，QUIC采用了一种更加健壮的方式来确定丢包。这个方式是独立于QUIC开发的，叫做RACK-TLP：Recent Acknowledgements and Tail Loss Probes。重复的ACK在某些场合是不能工作的，例如发送端在丢包之后并没有发送足够多的数据来触发重复ACK，又比如重传包自己又丢失了。同样的，包乱序也会触发快速重传，而此时并没有丢包。QUIC通过RACK-TLP中的两个机制来解决这里的问题： <ul><li>一个包在超过了一定时间，或者其后的第 K 个包被确认了（其中 K 是参数），还未被确认，那么就认为这个包丢包了。这可以确保少量的包乱序不被解读为丢包。K 建议最初设置为 3，并可以随后更新。这里的“超过一定时间”是指比测量的 RTT 略长一些的时间。</li><li>在“probe timeout interval”之后，如果还未收到 ACK，就发送一个探测包，并期望通过探测包的 ACK 来获取有关丢包的信息。这样可以确保即使数据包不能触发足够的重复 ACK，探测包也能诱发更多的 ACK，并暴露出接收端丢失的数据包。“probe timeout interval”会考虑 ACK 所能遇到的所有延时，具体来说是通过预估的 RTT 和其预估的变化值计算获得。</li></ul></li></ul><p>QUIC是当今世界最有趣的传输层协议研究之一。TCP有很多限制已经存在了数十年，但是QUIC代表了能够撼动TCP地位的最成功尝试之一。它同时也将TCP几十年来基于实际经验改良的拥塞控制算法作为基本能力集成进来。因为QUIC来源于HTTP以及Web的经验，它们是在TCP已经在互联网完全部署之后很久才兴起的，所以它是一个展示了网络分层设计优势的绝妙例子（即，应用层不用动，只需要优化传输层就能优化整体性能）。有关QUIC还有很多内容，其定义在RFC9000，其拥塞控制算法在RFC9002。</p><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>TCP</th><th>QUIC</th></tr></thead><tbody><tr><td>传输层协议</td><td>基于 TCP</td><td>基于 UDP</td></tr><tr><td>握手</td><td>三次握手</td><td>1-RTT（甚至 0-RTT）</td></tr><tr><td>加密</td><td>需搭配 TLS</td><td>默认集成 TLS 1.3</td></tr><tr><td>队头阻塞</td><td>可能发生</td><td>通过多路复用避免</td></tr><tr><td>连接迁移</td><td>不支持</td><td>支持（Connection ID）</td></tr><tr><td>拥塞控制</td><td>由内核控制</td><td>由应用控制</td></tr><tr><td>主要用途</td><td>HTTP/2、FTP、SMTP</td><td>HTTP/3、流媒体、游戏</td></tr></tbody></table><h2 id="tcp-friendly-protocols-tfrc" tabindex="-1">TCP-Friendly Protocols (TFRC) <a class="header-anchor" href="#tcp-friendly-protocols-tfrc" aria-label="Permalink to &quot;TCP-Friendly Protocols (TFRC)&quot;">​</a></h2><h2 id="multipath-transport" tabindex="-1">Multipath Transport <a class="header-anchor" href="#multipath-transport" aria-label="Permalink to &quot;Multipath Transport&quot;">​</a></h2><h2 id="mobile-cellular-networks" tabindex="-1">Mobile Cellular Networks <a class="header-anchor" href="#mobile-cellular-networks" aria-label="Permalink to &quot;Mobile Cellular Networks&quot;">​</a></h2>',19)]))}const p=e(o,[["render",d]]);export{P as __pageData,p as default};
