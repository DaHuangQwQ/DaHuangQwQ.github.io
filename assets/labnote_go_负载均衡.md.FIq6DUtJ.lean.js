import{_ as e,c as l,a2 as o,o as t}from"./chunks/framework.BQmytedh.js";const u=JSON.parse('{"title":"负载均衡","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/go/负载均衡.md","filePath":"labnote/go/负载均衡.md"}'),i={name:"labnote/go/负载均衡.md"};function r(p,a,n,c,s,d){return t(),l("div",null,a[0]||(a[0]=[o('<h1 id="负载均衡" tabindex="-1">负载均衡 <a class="header-anchor" href="#负载均衡" aria-label="Permalink to &quot;负载均衡&quot;">​</a></h1><h2 id="种类" tabindex="-1">种类 <a class="header-anchor" href="#种类" aria-label="Permalink to &quot;种类&quot;">​</a></h2><ol><li><p>轮询、随机</p><blockquote><p>有俩个假设 所有服务器的处理能力是一样的，所有请求所需的资源也是一样的</p></blockquote></li><li><p>加权轮询、加权随机</p><blockquote><p>权重通过注册中心传递</p></blockquote></li><li><p>哈希、加权哈希、一致性哈希</p></li><li><p>动态负载均衡算法（99%不会用）</p><ul><li>最小连接数 连接多路复用 连接数不准</li><li>最小活跃数 正在处理的请求 请求大小不一样 不太好用</li><li>最快响应时间算法 平均响应时间 99线 999线</li></ul><blockquote><p>微服务框架不具备全局信息</p><p>要有阈值 最小不能为负数， 最大不能超过哪个值</p></blockquote></li><li><p>设计自己的负载均衡算法</p><blockquote><p>信心通过服务端响应头携带自己的元数据指标、利用可观测平台，最高端的做法是前俩个和在一起使用</p></blockquote></li></ol><h2 id="failover-机制" tabindex="-1">FailOver 机制 <a class="header-anchor" href="#failover-机制" aria-label="Permalink to &quot;FailOver 机制&quot;">​</a></h2><h3 id="重试" tabindex="-1">重试 <a class="header-anchor" href="#重试" aria-label="Permalink to &quot;重试&quot;">​</a></h3><h2 id="本地缓存负载均衡-redis缓存负载均衡策略" tabindex="-1">本地缓存负载均衡 redis缓存负载均衡策略 <a class="header-anchor" href="#本地缓存负载均衡-redis缓存负载均衡策略" aria-label="Permalink to &quot;本地缓存负载均衡 redis缓存负载均衡策略&quot;">​</a></h2><p>哈希类负载均衡能解决这样的问题</p><p>同一个key必然命中同一个节点</p><p>显著提高缓存命中率 和 提高内存利用率</p><p>如果额外添加了一个节点 缓存命中率 骤然下降</p><p>所以用一致性哈希</p>',11)]))}const b=e(i,[["render",r]]);export{u as __pageData,b as default};
