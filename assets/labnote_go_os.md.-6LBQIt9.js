import{_ as o,c as i,a2 as a,o as t}from"./chunks/framework.BQmytedh.js";const u=JSON.parse('{"title":"操作系统","description":"","frontmatter":{},"headers":[],"relativePath":"labnote/go/os.md","filePath":"labnote/go/os.md"}'),e={name:"labnote/go/os.md"};function r(n,l,s,p,c,g){return t(),i("div",null,l[0]||(l[0]=[a('<h1 id="操作系统" tabindex="-1">操作系统 <a class="header-anchor" href="#操作系统" aria-label="Permalink to &quot;操作系统&quot;">​</a></h1><h2 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h2><p>虚拟内存的主要作用是提升系统效率和简化内存管理。</p><ol><li>内存扩展能力：</li></ol><ul><li>虚拟内存允许程序运行在比实际物理内存大的地址空间上。即使物理内存不足，系统也可以通过交换（swapping）将不常用的内存页移到磁盘中，使得多个程序能够同时运行。</li></ul><ol><li>进程隔离：</li></ol><ul><li>每个进程拥有独立的虚拟地址空间，防止进程间的内存访问冲突，提高系统稳定性和安全性。</li><li>使用虚拟内存，操作系统可以通过页面表设置访问权限，防止非法访问。</li></ul><ol><li>简化内存管理：</li></ol><ul><li>操作系统可以更灵活地分配和回收内存，无需手动考虑物理内存布局问题。</li><li>虚拟内存可以将程序逻辑地址与物理地址解耦。</li></ul><p><strong>虚拟内存</strong></p><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存</p><p>操作系统是管理虚拟地址与物理地址之间的关系主要有<strong>内存分段和内存分页</strong></p><p><strong>内存分段</strong></p><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段的形式把这些段分离出来。</strong></p><p><strong>内存分页</strong></p><p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</p><p><strong>段页式内存管理</strong></p><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p><p><strong>Linux内存管理</strong></p><p>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理</p><h2 id="进程管理" tabindex="-1">进程管理 <a class="header-anchor" href="#进程管理" aria-label="Permalink to &quot;进程管理&quot;">​</a></h2><h3 id="进程" tabindex="-1">进程 <a class="header-anchor" href="#进程" aria-label="Permalink to &quot;进程&quot;">​</a></h3><p>在操作系统中，是用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程的。</p><h3 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h3><p>在早期的操作系统中都是以进程作为独立运行的基本单位，直到后面，计算机科学家们又提出了更小的能独立运行的基本单位，也就是<strong>线程</strong></p><p><strong>进程间通信</strong></p><ul><li>管道</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>信号</li><li>socket</li></ul><h3 id="进程与线程的比较" tabindex="-1">进程与线程的比较 <a class="header-anchor" href="#进程与线程的比较" aria-label="Permalink to &quot;进程与线程的比较&quot;">​</a></h3><ul><li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执行的时间和空间开销；</li></ul><h3 id="调度" tabindex="-1">调度 <a class="header-anchor" href="#调度" aria-label="Permalink to &quot;调度&quot;">​</a></h3><ul><li>先来先服务调度算法</li><li>最短作业优先调度算法</li><li>高响应比优先调度算法</li><li>时间片轮转调度算法</li><li>最高优先级调度算法</li><li>多级反馈队列调度算法</li></ul><h3 id="锁" tabindex="-1">锁 <a class="header-anchor" href="#锁" aria-label="Permalink to &quot;锁&quot;">​</a></h3><ul><li>互斥锁：<strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li><li>自旋锁：<strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li><li>读写锁：<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>。</li><li>悲观锁：它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</li><li>乐观锁：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作，乐观锁全程并没有加锁，所以它也叫无锁编程</strong>。</li></ul><h2 id="i-o-模型" tabindex="-1">I/O 模型 <a class="header-anchor" href="#i-o-模型" aria-label="Permalink to &quot;I/O 模型&quot;">​</a></h2><ul><li><strong>阻塞I/O（Blocking I/O）</strong>：调用I/O操作时，进程会被阻塞，直到数据准备好或操作完成后才继续执行。</li><li><strong>非阻塞I/O（Non-blocking I/O）</strong>：I/O操作不会阻塞进程，如果数据没有准备好，立即返回错误或状态，进程可以继续执行其他操作。</li><li><strong>I/O多路复用（I/O Multiplexing）</strong>：使用<code>select</code>、<code>poll</code>、<code>epoll</code>等系统调用，允许程序同时等待多个I/O操作，当其中任意一个就绪时进行处理。</li><li><strong>信号驱动I/O（Signal-driven I/O）</strong>：在数据准备好时，内核通过信号通知进程进行I/O操作，进程在接收到信号后再进行数据读取或写入。</li><li><strong>异步I/O（Asynchronous I/O）</strong>：发起I/O请求后立即返回，内核在后台完成I/O操作，并在操作完成时通知进程。进程不需要等待I/O完成即可继续执行其他任务。</li></ul><h3 id="i-o多路复用" tabindex="-1">I/O多路复用 <a class="header-anchor" href="#i-o多路复用" aria-label="Permalink to &quot;I/O多路复用&quot;">​</a></h3><p><strong>select</strong>：</p><ul><li>早期的I/O多路复用机制，使用固定长度的数组表示文件描述符集。每次调用select时都需要重新构建和检查文件描述符集。</li><li>支持的文件描述符数量有限（通常为1024），在大规模连接的场景下效率较低。</li></ul><p><strong>poll</strong>：</p><ul><li>poll与select类似，但使用动态数组来存储文件描述符，因此没有select的最大连接数限制。</li><li>每次调用时仍需遍历全部描述符，在处理大量连接时效率不高。</li></ul><p><strong>epoll</strong>：</p><ul><li>epoll是Linux系统对select和poll的优化，提供了边缘触发（ET）和水平触发（LT）模式。</li><li>不会遍历所有文件描述符，而是通过事件通知的方式，只处理实际发生变化的描述符，适合高并发服务器。</li><li>epoll在注册文件描述符后，只需调用一次添加操作，后续的事件管理更高效。</li></ul><h3 id="reactor" tabindex="-1">Reactor <a class="header-anchor" href="#reactor" aria-label="Permalink to &quot;Reactor&quot;">​</a></h3><p>Reactor 是一种用于处理并发I/O事件的设计模式，特别适合于网络服务器的开发。它通过事件驱动机制和非阻塞I/O，能够高效地处理大量并发连接。</p><p>Reactor模式的核心思想是将I/O事件与相应的处理程序解耦，并通过事件分发器（Event Demultiplexer）来管理事件和响应操作。</p><p>Reactor的工作方式：</p><ul><li>事件驱动：Reactor通过监听多个事件源（如Socket连接、读写事件），在有事件发生时调用对应的处理程序（Handler）。</li><li>非阻塞I/O：使用非阻塞I/O模型，Reactor能够在单个或少数线程中高效处理大量I/O操作，避免了线程的频繁切换。</li><li>事件分发与处理：Reactor会将收到的事件（如连接到达、数据可读、数据可写）分发给相应的事件处理器，处理器对事件进行处理。</li></ul><h2 id="零拷贝" tabindex="-1">零拷贝 <a class="header-anchor" href="#零拷贝" aria-label="Permalink to &quot;零拷贝&quot;">​</a></h2><p>零拷贝是一种优化数据传输的技术，核心思想是尽量避免数据在内存之间的拷贝，并且做到 CPU 完全不参与拷贝，这也就是零拷贝的零的含义。</p><p>零拷贝技术有很多种实现方式。一种实现方式就是 sendfile 这种，也就是我前面描述的那个过程。另外一种实现是所谓的内存映射文件，也就是 Memory Mapped File。这种实现方式是让应用通过读写一块虚拟内存来间接操作文件。</p>',50)]))}const d=o(e,[["render",r]]);export{u as __pageData,d as default};
