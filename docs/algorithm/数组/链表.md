# 链表

## 俩数相加

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

func addTwoNumbers(l1, l2 *ListNode) *ListNode {
	var (
		tail  *ListNode
		head  *ListNode
		carry = 0
	)
	for l1 != nil || l2 != nil {
		n1, n2 := 0, 0
		if l1 != nil {
			n1 = l1.Val
			l1 = l1.Next
		}
		if l2 != nil {
			n2 = l2.Val
			l2 = l2.Next
		}
		sum := n1 + n2 + carry
        sum, carry = sum % 10, sum / 10
        if head == nil {
            head = &ListNode{Val: sum}
            tail = head
        } else {
            tail.Next = &ListNode{Val: sum}
            tail = tail.Next
        }
	}
    if carry > 0 {
        tail.Next = &ListNode{Val: carry}
    }
    return head
}
```

## 合并俩个有序链表

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	t := ListNode{}
    cur := &t
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            cur.Next = l1
            l1 = l1.Next
        } else {
            cur.Next = l2
            l2 = l2.Next
        }
        cur = cur.Next
    }
    if l1 != nil {
        cur.Next = l1
    } else {
        cur.Next = l2
    }
    return t.Next
}
```

## 反转链表

![image-20250215150348085](./assets/image-20250215150348085.png)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, left int, right int) *ListNode {
	res := &ListNode{Next:head}
    l := res
    for i := 0;i < left - 1;i++ {
        l = l.Next
    }

    var pre, cur *ListNode = nil, l.Next

    for i := 0;i < right - left + 1; i++ {
        next := cur.Next
        cur.Next = pre
        pre = cur
        cur = next
    }

    l.Next.Next = cur
    l.Next = pre

    return res.Next
}
```

## k个一组反转链表

![image-20250215151406612](./assets/image-20250215151406612.png)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseKGroup(head *ListNode, k int) *ListNode {
	n := 0
	for t := head; t != nil; t = t.Next {
		n++
	}

	res := &ListNode{Next: head}
	l := res

	var pre, cur *ListNode = nil, l.Next

	for ; n >= k; n -= k {
		for i := 0; i < k; i++ {
			next := cur.Next
			cur.Next = pre
			pre = cur
			cur = next
		}

		nxt := l.Next
		l.Next.Next = cur
		l.Next = pre
		l = nxt
	}

	return res.Next
}
```

## 删除倒数第N个数

```go
func removeNthFromEnd(head *ListNode, k int) *ListNode {
	res := &ListNode{Next: head}
	l, r := res, res
	for n := k; n > 0; n-- {
		r = r.Next
	}
	for r.Next != nil {
		l = l.Next
		r = r.Next
	}
	l.Next = l.Next.Next
	return res.Next
}
```

## 删除重复元素

```go
func deleteDuplicates(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }
    cur := head
    for cur.Next != nil {
        if cur.Next.Val == cur.Val {
            cur.Next = cur.Next.Next
        } else {
            cur = cur.Next
        }
    }
    return head
}
```

## 删除重复元素2

```go
func deleteDuplicates(head *ListNode) *ListNode {
    res := &ListNode{Next:head}
    cur := res
    for cur.Next != nil && cur.Next.Next != nil { // 比较下一个节点 和下下一个节点
        val := cur.Next.Val
        if cur.Next.Next.Val == val {
            for cur.Next != nil && cur.Next.Val == val {
                cur.Next = cur.Next.Next
            }
        } else {
            cur = cur.Next
        }
    }
    return res.Next
}
```

## 旋转链表

```go
func rotateRight(head *ListNode, k int) *ListNode {
    if k == 0 || head == nil || head.Next == nil {
        return head
    }
    n := 1
    i := head
    for ; i.Next != nil; i = i.Next {
        n++
    }
    add := n - k % n
    if add == n {
        return head
    }
    i.Next = head
    for add > 0 {
        i = i.Next
        add--
    }
    res := i.Next
    i.Next = nil
    return res
}
```

## 分隔链表

```go
func partition(head *ListNode, x int) *ListNode {
    i := &ListNode{}
    iH := i
    j := &ListNode{}
    jH := j
    for head != nil {
        if head.Val < x {
            i.Next = head
            i = i.Next
        } else {
            j.Next = head
            j = j.Next
        }
        head = head.Next
    }
    j.Next = nil
    i.Next = jH.Next
    return iH.Next
}
```

## LRU

```go
type LRUCache struct {
    cap int
    list *list.List
    cache map[int]*list.Element
}

type entry struct {
    key, val int
}

func Constructor(capacity int) LRUCache {
    return LRUCache{capacity, list.New(), map[int]*list.Element{}}
}


func (this *LRUCache) Get(key int) int {
    node := this.cache[key]
    if node == nil {
        return -1
    }
    this.list.MoveToFront(node)
    return node.Value.(entry).val
}


func (this *LRUCache) Put(key int, value int)  {
    if node := this.cache[key]; node != nil {
        node.Value = entry{key, value}
        this.list.MoveToFront(node)
        return
    }
    this.cache[key] = this.list.PushFront(entry{key, value})
    if len(this.cache) > this.cap {
        delete(this.cache, this.list.Remove(this.list.Back()).(entry).key)
    }
}

```

