# 图论



## Floyd

**这段代码的基本思想就是：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。**

所有的边全部给出，**按照时间顺序更新每一个可用的点**（即修建好村庄），对于每个时间点进行两点之间询问，求**对于目前建设的所有村庄**来说**任意两点之间的最短路**

**不正好就是Floyd算法中使用前k个节点更新最短路的思维吗？**

```c++
// https://www.luogu.com.cn/problem/P1119
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 1000;
int n,m,q;
int a[N];
int f[N][N];
void update(int k){
    for(int i = 0;i < n;i++){
        for(int j = 0;j < n;j++){
            if(f[i][j] > f[i][k] + f[k][j]){
                f[j][i] = f[i][j] = f[i][k] + f[k][j];
            }
        }
    }
}
int main(){
    cin >> n >> m;
    memset(f, 0x3f, sizeof f);
    for(int i = 0;i < n;i++){
        cin >> a[i];
    }
    for(int i = 1;i <= m;i++){
        int u,v,w;
        cin >> u >> v >> w;
        f[u][v] = f[v][u] = w;
    }
    for(int i = 0;i < n;i++){
        f[i][i] = 0;
    }
    cin >> q;
    int now = 0;
    for(int i =1 ;i <= q;i++){
        int x1,x2,x3;
        cin >> x1 >> x2 >> x3;
        while(a[now] <= x3 && now < n){
            update(now);
            now++;
        }
        if(a[x1] > x3 || a[x2] > x3){
            cout << -1 << endl;
        }else{
            if(f[x1][x2] == 0x3f3f3f3f) cout << -1 << endl;
            else cout << f[x1][x2] << endl;
        }
    }
    return 0;
}
```



## spfa最短路算法模版

```c++
#include <iostream>
#include <deque>
#include <cstring>
#include <vector>
using namespace std;
const int N = 10010;
const int M = 2 * N;
struct edge{int to,w;};

vector<edge> e[M];
int dis[N],step[N],n,m,ans;
bool vis[N];

void spfa(const int s){
	deque<int> q;
	memset(dis, 0x3f, sizeof dis);
	memset(vis, false, sizeof vis);
	q.push_front(s);
	dis[s] = 0;
	vis[s] = true;
	while(!q.empty()){
		int u = q.front();
		q.pop_front();
		vis[u] = false;
		++step[u];
		if(step[u] > n){
			puts("Forever love");exit(0);
			return;
		}
		for(auto v : e[u]){
			if(dis[v.to] > dis[u] + v.w){
				dis[v.to] = dis[u] + v.w;
				if(!vis[v.to]){
					vis[v.to] = true;
					if(!q.empty() && dis[v.to] > dis[q.front()]){
						q.push_front(v.to);
					}else{
						q.push_back(v.to);
					}
				}
			}
		}
	}
}

int main(){
	cin >> n >> m;
	for(int i = 1;i <= m;i++){
		int u,v,w; cin >> u >> v >> w;
		e[u].push_back(edge{v,-w});
	}
	spfa(1);
	ans = dis[n];
	spfa(n);
	ans = min(ans, dis[1]);
	cout << ans << endl;
	return 0;
}
```

## Dijsktra算法模版

```c++
#include <vector>
#include <iostream>
#include <queue>
#include <cstring>
using namespace std;

typedef pair<int,int> PII;
const int N = 100010;
const int M = 2 * N;

struct edge{
	int v, w ,next;
} e[M];

int n,m,s;

int head[N];
bool vis[N];
int dis[N];

void add(int u, int v, int w){
	static int cnt = 0;
	e[++cnt] = (edge){v , w , head[u]};
	head[u] = cnt;
}

priority_queue<PII, vector<PII>, greater<PII>> q;

void dijkstra(){
	memset(dis, 0x3f, sizeof dis);
	q.push({0,s});
	dis[s] = 0;
	while(!q.empty()){
		int u = q.top().second;
		int d = q.top().first;
		q.pop();
		if (d!=dis[u]) continue;
		for (int i=head[u];i;i=e[i].next) {
			int v=e[i].v,w=e[i].w;
			if (dis[u]+w<dis[v]) dis[v]=dis[u]+w,q.push({dis[v],v});
		}
	}
}


int main(){
	cin >> n >> m >> s;
	while(m--){
		int a,b,c; cin >> a >> b >> c;
		add(a,b,c);
	}
	dijkstra();
	for(int i = 1;i <= n;i++){
		printf("%d%c",dis[i]," \n"[i==n]);
	}
	return 0;
}
```



## 克鲁斯卡尔最小生成树算法

###     给出一颗带权的树，删除任意条边，求出使得给定的点不连通的最小权值。

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 100010;
struct edge{
	int u,v,w;
	const bool operator<(const edge & a) const{
		return w > a.w;
	}
}e[N];
long long n,m,tot,sum,res,p[N];
bool vis[N];

int find(int a){
	if(p[a] != a) p[a] = find(p[a]);
	return p[a];
}

int main(){
	cin >> n >> m;
	for(int i = 0; i < m;i++){
		int u; cin >> u;
		vis[u] = true; // 规避的节点
	}
	for(int i = 1;i < n;i++){
		int u,v,w; cin >> u >> v >> w;
		e[i] = edge{u,v,w};
		tot += w; // res = tot - sum
	}
	for(int i = 0;i <= n;i++) p[i] = i;
	sort(e+1, e+n);
	for(int i = 1;i < n;i++){	
		int u = find(e[i].u);
		int v = find(e[i].v);
		if(vis[u] && vis[v]) continue;
		if(u != v){
			p[u] = v;
		}
		sum += e[i].w;
		if(vis[u]) vis[v] = true; // 标记一对相互连接的节点，以确保它们被同时处理或不被同时处理
		if(vis[v]) vis[u] = true;
	}
	cout << tot - sum << endl;
	return 0;
}
```

### 只要起点和终点在一个集合了，就输出最后进入集合的那条边的边权值。

``` c++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 50010;
struct edge{
	int u,v,w;
	bool operator<(const edge& a)const{
		return w < a.w;
	}
} e[N];

int p[N],n,m,s,t,res;

int find(int s){
	if(p[s] != s) p[s] = find(p[s]);
	return p[s];
}

int main(){
	cin >> n >> m >> s >> t;
	for(int i = 1;i <= m;i++){
		int u,v,w; cin >> u >> v >> w;
		e[i] = edge{u,v,w};
	}
	for(int i = 1;i <= n;i++) p[i] = i;
	sort(e+1, e+m+1);
	for(int i = 1;i <= m;i++){
		int u = e[i].u,v=e[i].v,w=e[i].w;
		u = find(u);
		v = find(v);
		if(u != v){
			p[u] = v;
			// cout << w << endl;
			// res = max(w, res);
		}
		if(find(s) == find(t)){ // 贪心算法 只要是找到起始点和最终点即可
			cout << w << endl;
			return 0;
		}
	}
	// cout << res << endl;
	return 0;
}
```

### n个点 m条边 连成k个树的最小代价

``` c++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 10010;
struct edge{
	int u,v,w;
	bool operator<(const edge & a)const {
		return w < a.w;
	}
}e[N];

int p[N],res,sum,n,m,k;

int find(int a){
	if(p[a] != a) p[a] = find(p[a]);
	return p[a];
}

int main(){
	cin >> n >> m >> k;
	for(int i = 1;i <= m;i++){
		int u,v,w; cin >> u >> v >> w;
		e[i] = edge{u,v,w};
	}
	for(int i = 0;i < n;i++) p[i] = i;
	sort(e+1, e+1+m);
	for(int i = 1;i <= m;i++){
		int u = find(e[i].u);
		int v = find(e[i].v);
		if(u != v){
			p[u] = v;
			sum++;
			res += e[i].w;
		}
		if(sum == n - k){ // 如果 sum = n - k 则认为用最小的代价连成了 k 棵树 贪心算法
			cout << res << endl;
			return 0;
		}
	}
	cout << "No Answer" << endl;

	return 0;
}
```

### 引入了一个额外的超级源点和超级汇点。看似n个节点 实际 n + 1 个

```c++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 50010;
struct edge{
	int u,v,w;
	const bool operator<(const edge & a)const{
		return w < a.w;
	}
}e[N];
int n,res,w[N],p[N],idx;

int find(int a){
	if(p[a] != a) p[a] = find(p[a]);
	return p[a];
}
void add(int u, int v,int w){
	++idx;
	e[idx] = edge{u,v,w};
}
int main(){
	cin >> n;
	for(int i = 1;i <= n;i++){ // 每个农场与水的距离
		int c; cin >> c;
		add(i,n+1,c);
		add(n+1,i,c);
	}
	for(int i = 1;i <= n;i++){
		for(int j = 1;j <= n;j++){
			int c; cin >> c;
			if(i < j) continue;
			add(i,j,c);
		}
	}
	for(int i = 0;i <= n;i++) p[i] = i;
	sort(e+1, e+idx+1);
	for(int i = 1;i <= idx;i++){
		int u = find(e[i].u);
		int v = find(e[i].v);
		if(p[u] != p[v]){
			p[u] = v;
			res += e[i].w;
		}
	}
	cout << res << endl;
	return 0;
}
```



## prim最小生成树算法

``` c++
#include <iostream>
#include <cstring>
using namespace std;
const int N = 510;

int g[N][N],n,m;
int dis[N];
bool vis[N];

int prim(){
	memset(dis, 0x3f, sizeof dis);
	int res = 0;
	for(int i = 0;i <m;i++){
		int t = -1;
		for(int j = 1;j <= m;j++){
			if(!vis[j] && (t == -1 || dis[t] > dis[j]))
				t = j;
		}
		if(i && dis[t] == 0x3f3f3f3f) return 0x3f3f3f3f;
		if(i) res += dis[t];
		for(int j = 1;j <= m;j++){
			dis[j] = min(dis[j], g[t][j]);
		}
		vis[t] = true;
	}
	return res;
}

int main(){
	cin >> n >> m;
	for(int i = 1;i <= m;i++){
		for(int j = 1;j <= m; j++){
			cin >> g[i][j];
			if(g[i][j] == 0 || g[i][j] > n)
				g[i][j] = n;
		}
	}
	cout << n + prim() << endl;
	return 0;
}
```

## 强连通分量

### tarjan算法模版

```c++
#include <vector>
#include <iostream>
using namespace std;
const int N = 20010;
struct edge{
	int y;
};
vector<edge> e[N];
int tim,dfn[N],low[N],vis[N],n,m,num,root;

void Tarjan(int x){
	int son = 0;
	dfn[x] = low[x] = ++tim;
	for(auto v : e[x]){
		int y = v.y;
		if(!dfn[y]){
			son++;
			Tarjan(y);
			low[x] = min(low[x], low[y]);
			if(dfn[x] <= low[y] && x != root){
				num += !vis[x];
				vis[x] = true;
			}
		}
		else{
			low[x] = min(low[x], dfn[y]);
		}
	}
	if(son >= 2 && x == root){
		num += !vis[x];
		vis[x] = true;
	}
}

int main(){
	cin >> n >> m;
	for(int i = 1;i <= m;i++){
		int u,v; cin >> u >> v;
		e[v].push_back(edge{u});
		e[u].push_back(edge{v});
	}
	for(int i = 1;i <= n;i++){
		if(dfn[i] == 0){
			root = i;
			Tarjan(i);
		}
	}
	cout << num << endl;
	for(int i = 1;i <= n;i++){
		if(vis[i]) cout << i << " ";
	}
	return 0;
}
```









# 动态规划

## 背包问题

### 01背包问题

```c++
#include <iostream>
using namespace std;
const int N = 10010;

int w[N],v[N],n,m;
int dp[N][N];
int main(){
    cin >> m >> n;
    for(int i = 1;i <= n;i++){
        cin >> w[i] >> v[i];
    }
    for(int i = 1;i <= n;i++){
        for(int j = m;j >= 0;j--){
            if(j >= w[i]){
                dp[i][j] = max(dp[i-1][j- w[i]] + v[i], dp[i-1][j]);
            }else{
                dp[i][j] = dp[i-1][j];
            }

        }
    }
    cout << dp[n][m] << endl;
    return 0;
}
```



## 记忆化搜索

``` c++
#include <iostream>
using namespace std;
const int N = 1000;

int board[N][N],n,m,res;
int s[N][N];
int dx[] = {1,-1,0,0};
int dy[] = {0,0,1,-1};

int dfs(int x,int y){
    if(s[x][y]) return s[x][y];
    s[x][y] = 1;
    for(int i = 0;i < 4;i++){
        int xx = dx[i] + x;
        int yy = dy[i] + y;
        if(xx < 1 || xx > n || yy < 1 || yy > m || board[xx][yy] >= board[x][y]) continue;
        dfs(xx,yy);
        s[x][y] = max(s[xx][yy] + 1, s[x][y]);
    }
    return s[x][y];
}

int main(){
    cin >> n >> m;
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            cin >> board[i][j];
        }
    }
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            res = max(res, dfs(i,j));
        }
    }
    cout << res << endl;
}
```

# 进阶搜索

## IDA*算法

```c++
#include <iostream>
#include <cstring>
using namespace std;

int ans[7][7] = {
    {0,0,0,0,0,0},
    {0,1,1,1,1,1},
    {0,0,1,1,1,1},
    {0,0,0,2,1,1},
    {0,0,0,0,0,1},
    {0,0,0,0,0,0}
};
int board[7][7], success;
const int dx[]={0,1,1,-1,-1,2,2,-2,-2};
const int dy[]={0,2,-2,2,-2,1,-1,1,-1};

int evaluate(){
    int cnt = 0;
    for(int i = 1;i <= 5;i++){
        for(int j = 1;j <= 5;j++){
            if(board[i][j] != ans[i][j]){
                cnt++;
            }
        }
    }
    return cnt;
}

void A_star(int deep, int x, int y, int maxDeep){
    if(deep == maxDeep){
        if(evaluate() == 0)success = 1;
        return;
    }
    if(success) return;
    for(int i = 1;i <= 8;i++){
        int nx = x + dx[i];
        int ny = y + dy[i];
        if(nx < 1 || nx > 5 || ny < 1 || ny > 5) continue;
        swap(board[x][y], board[nx][ny]);
        int eva = evaluate();
        if(eva + deep <= maxDeep) A_star(deep+1,nx,ny,maxDeep);
        swap(board[x][y], board[nx][ny]);
    }
}

int main(){
    int n; cin >> n;
    while(n--){
        success = 0;
        int x,y;
        for(int i = 1;i <= 5;i++){
            string str; cin >> str;
            for(int j = 1;j <= 5;j++){
                if(str[j-1] == '*'){
                    x = i;
                    y = j;
                    board[i][j] = 2;
                }else
                    board[i][j] = str[j-1] - '0';
            }
        }
        if(!evaluate()){
            cout << "0" << endl;
            continue;
        }
        for(int i = 1;i <= 15;i++){
            A_star(0,x,y,i);
            if(success){
                cout << i << endl;
                goto end;
            }
        }
        cout << -1 << endl;
        end:;
    }
    return 0;
}
```

# 树

## 最近公共祖先（倍增法）

```c++
#include <vector>
#include <iostream>
using namespace std;
const int N = 500010;

vector<int> g[N];
int d[N][30], height[N];
int n,m,k;

void dfs(int u,int fa)
{
    height[u]=height[fa]+1;
    d[u][0]=fa;
    for(int i=1;(1<<i)<=height[u];i++)
        d[u][i]=d[d[u][i-1]][i-1];
    for(int i = 0;i < g[u].size();i++){
        int v = g[u][i];
        if(v != fa)
            dfs(v, u);
    }
} 
int lca(int a,int b)                                          //非常标准的lca查找
{
    if(height[a]>height[b])
        swap(a,b);           //保证a是在b结点上方，即a的深度小于b的深度
    for(int i=20;i>=0;i--)
        if(height[a]<=height[b]-(1<<i))
            b=d[b][i];             //先把b移到和a同一个深度
    if(a==b)
        return a;                 //特判，如果b上来和就和a一样了，那就可以直接返回答案了
    for(int i=20;i>=0;i--)
    {
        if(d[a][i]==d[b][i])
            continue;
        else
            a=d[a][i],b=d[b][i];           //A和B一起上移
    }
    return d[a][0];               //找出最后a值的数字
}

int main(){
    cin >> n >> m >> k;
    for(int i = 1;i < n;i++){
        int u,v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(k, 0);
    while(m--){
        int a,b; cin >> a >> b;
        cout << lca(a,b) << endl;
    }
    return 0;
}
```

## 最近公共祖先（重链剖分）

```c++
#include <iostream>
#include <vector>
using namespace std;
const int N = 500100;
int n,m,r,p;
int son[N],fa[N],dep[N],sz[N],top[N],id[N],nw[N],cnt;
vector<int> g[N];
void dfs1(int u, int father){
    fa[u] = father;
    dep[u] = dep[father] + 1;
    sz[u] = 1;
    for(int i = 0;i < g[u].size(); i++){
        int v = g[u][i];
        if(v == father) continue;
        dfs1(v, u);
        sz[u] += sz[v];
        if(sz[son[u]] < sz[v]){
            son[u] = v; // 重儿子
        }
    }
}

void dfs2(int u, int t){
    top[u] = t;
    if(!son[u]) return;
    dfs2(son[u], t);  // 搜重儿子
    for(int i = 0;i < g[u].size(); i++){
        int v = g[u][i];
        if(v == fa[u] || v == son[u]) continue;
        dfs2(v,v);
    }
}

int lca(int a, int b){
    while(top[a] != top[b]){
        if(dep[top[a]] < dep[top[b]]) swap(a, b);
        a = fa[top[a]];
    }
    return dep[a] < dep[b] ? a : b;
}

int main(){
    cin >> n >> m >> r;
    for(int i = 1; i < n;i++){
        int a,b; cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    dfs1(r, 0);
    dfs2(r, r);
    while(m--){
        int a,b;
        cin >> a >> b;
        cout << lca(a, b) << endl;
    }
    return 0;
}
```



## 树上差分

```c++
#include <vector>
#include <iostream>
using namespace std;

const int N = 500100;

vector<int> g[N];
int dp[N][30],n,m, dis[N], power[N],res;

void dfs(int u, int fa){
    dis[u] = dis[fa] + 1;
    dp[u][0] = fa;
    for(int i = 1; (1 << i) <= dis[u];i++){
        dp[u][i] = dp[dp[u][i-1]][i-1];
    }
    for(int i = 0;i < g[u].size(); i++){
        int v = g[u][i];
        if(v == fa) continue;
        dfs(v, u);
    }
}

int lca(int a, int b){
    if(dis[a] > dis[b])
        swap(a,b);
    for(int i = 20; i>=0; i--) 
        if(dis[a] <= dis[b] - (1 << i)) 
            b = dp[b][i];
    if(a==b)
        return a;
    for(int i = 20; i>=0;i--){
        if(dp[a][i] != dp[b][i]){
            a = dp[a][i];
            b = dp[b][i];
        }
    }
    return dp[a][0];
}

void get(int u, int fa){
    for(int i = 0;i < g[u].size(); i++){
        int v = g[u][i];
        if(v == fa) continue;
        get(v, u);
        power[u] += power[v];
    }
    res = max(res, power[u]);
}

int main(){
    cin >> n >> m;
    for(int i = 1;i < n;i++){
        int u,v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1, 0);
    while(m--){
        int a,b; cin >> a >> b;
        int lc = lca(a,b);
        ++power[a];
        ++power[b];
        --power[lc];
        --power[dp[lc][0]];
    }
    get(1, 0);
    cout << res << endl;
    return 0;
}
```

## Lca+重链剖分

```c++
#include <iostream>
#include <vector>
using namespace std;
const int N = 500100;
int n,m,r,p;
int son[N],fa[N],dep[N],sz[N],top[N],id[N],nw[N],cnt;
vector<int> g[N];
void dfs1(int u, int father){
    fa[u] = father;
    dep[u] = dep[father] + 1;
    sz[u] = 1;
    for(int i = 0;i < g[u].size(); i++){
        int v = g[u][i];
        if(v == father) continue;
        dfs1(v, u);
        sz[u] += sz[v];
        if(sz[son[u]] < sz[v]){
            son[u] = v; // 重儿子
        }
    }
}

void dfs2(int u, int t){
    top[u] = t;
    if(!son[u]) return;
    dfs2(son[u], t);  // 搜重儿子
    for(int i = 0;i < g[u].size(); i++){
        int v = g[u][i];
        if(v == fa[u] || v == son[u]) continue;
        dfs2(v,v);
    }
}

int lca(int a, int b){
    while(top[a] != top[b]){
        if(dep[top[a]] < dep[top[b]]) swap(a, b);
        a = fa[top[a]];
    }
    return dep[a] < dep[b] ? a : b;
}

int main(){
    cin >> n >> m >> r;
    for(int i = 1; i < n;i++){
        int a,b; cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    dfs1(r, 0);
    dfs2(r, r);
    while(m--){
        int a,b;
        cin >> a >> b;
        cout << lca(a, b) << endl;
    }
    return 0;
}
```



## 重链剖分+线段树

```c++
// https://www.luogu.com.cn/problem/P3178
#include <iostream>
#define endl "\n"
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const int N = 1000005;
struct{
    int to, next;
} e[2*N];
int head[N],idx;
void add(int u,int v){
    ++idx;
    e[idx].to = v;
    e[idx].next = head[u];
    head[u] = idx;
}
ll n,m,a[N],b[N];
// 树链剖分
ll top[N],fa[N],son[N],id[N],deep[N],size[N],cnt;
void dfs1(int u, int father){
    deep[u] = deep[father] + 1;
    fa[u] = father;
    size[u] = 1;
    for(int i = head[u]; i ; i = e[i].next){
        int v = e[i].to;
        if(v == father) continue;
        dfs1(v, u);
        size[u] += size[v];
        if(size[son[u]] < size[v]) son[u] = v;
    }
}
void dfs2(int u, int t){
    id[u] = ++cnt;
    top[u] = t;
    a[cnt] = b[u];
    if(!son[u]) return;
    dfs2(son[u], t);
    for(int i = head[u]; i; i = e[i].next){
        int v = e[i].to;
        if(v == fa[u] || v == son[u]) continue;
        dfs2(v,v);
    }
}
// 线段树
struct{
    int l,r;
    ll add, sum;
} tree[N*4];
#define lson k << 1
#define rson lson|1

void pushup(int k){
    tree[k].sum = (tree[lson].sum + tree[rson].sum);
}
void pushdown(int k){
    if(!tree[k].add) return;
    tree[lson].sum += tree[k].add * (tree[lson].r - tree[lson].l + 1);
    tree[rson].sum += tree[k].add * (tree[rson].r - tree[rson].l + 1);
    tree[lson].add += tree[k].add;
    tree[rson].add += tree[k].add;
    tree[k].add = 0;
}
void build(int k, int l, int r){
    tree[k].l = l;
    tree[k].r = r;
    if(l == r){
        tree[k].sum = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(lson, l, mid);
    build(rson, mid+1, r);
    pushup(k);
}
ll query(int k, int l,int r){
    ll ans = 0;
    if(tree[k].l >= l && tree[k].r <= r){
        return tree[k].sum;
    }
    int mid = (tree[k].l + tree[k].r) >> 1;
    pushdown(k);
    if(l <= mid) ans += query(lson, l, r);
    if(r > mid) ans += query(rson, l , r);
    return ans;
}
void addInterval(int k, int l,int r, ll val){
    if(tree[k].l >= l && tree[k].r <= r){
        tree[k].add += val;
        tree[k].sum += val * (tree[k].r - tree[k].l + 1);
        return;
    }
    int mid = (tree[k].l + tree[k].r) >> 1;
    pushdown(k);
    if(l <= mid) addInterval(lson, l, r, val);
    if(r > mid)  addInterval(rson, l, r, val);
    pushup(k);
}
ll queryRoad(int x,int y){
    ll ans = 0;
    while(top[x] != top[y]){
        if(deep[top[x]] < deep[top[y]]) swap(x, y);
        ans += query(1, id[top[x]], id[x]);
        x = fa[top[x]];
    }
    if(id[x] > id[y]) swap(x, y);
    ans += query(1, id[x], id[y]);
    return ans;
}
void addPoint(int k,int x, int val){
    if(tree[k].l == tree[k].r){
        tree[k].sum += val;
        return;
    }
    int mid = (tree[k].l + tree[k].r) >> 1;
    pushdown(k);
    if(x <= mid) addPoint(lson, x, val);
    else addPoint(rson, x, val);
    pushup(k);
}

int main(){
    //  freopen("P3178_2.in","r",stdin);
    cin >> n >> m;
    for(int i = 1;i <= n;i++){
        cin >> b[i];
    }
    for(int i = 1;i < n;i++){
        int a,b; cin >> a >> b;
        add(a,b);add(b,a);
    }
    dfs1(1,0);
    dfs2(1,1);
    build(1,1,n);
    while(m--){
        ll op,a,b; cin >> op;
        if(op == 1){
            cin >> a >> b;
            addPoint(1, id[a], b);
        }
        if(op == 2){
            cin >> a >> b;
            addInterval(1, id[a], id[a] + size[a] - 1, b);
        }
        if(op == 3){
            cin >> a;
            cout << queryRoad(1, a) << endl;
        }
    }
}
```

## 树上启发式合并(处理树上不带修改的离线子树问题)

```c++
// https://www.luogu.com.cn/problem/CF600E
#include <iostream>
#include <vector>
#include <algorithm>
#define ll long long
using namespace std;
const int N = 1e5+10;
int n;
ll col[N],res[N],cnt[N],mx,sum;
// struct{
//     int to,next;
// }e[N << 2];
// int head[N],idx;
// void addEdge(int u, int v){
//     e[++idx].to = v;
//     e[idx].next = head[u];
//     head[u] = idx;
// }
vector<int> g[N];
ll son[N],deep[N],siz[N],fa[N];
void dfs1(int x, int father){
    deep[x] = deep[father] + 1;
    siz[x] = 1;
    for(int i = 0;i < g[x].size();i++){
        int y = g[x][i];
        if(y == father) continue;
        dfs1(y, x);
        siz[x] += siz[y];
        if(siz[son[x]] < siz[y]) son[x] = y;
    }
}
void add(int x, int fa, int son){
    cnt[col[x]]++;
    if(cnt[col[x]] > mx) mx = cnt[col[x]], sum = col[x];
    else if(cnt[col[x]] == mx) sum += col[x];

    for(int i = 0;i < g[x].size();i++){
        int y = g[x][i];
        if(y == fa || y == son) continue;//重子树除外
        add(y, x, son);
    }
}
void sub(int x, int fa){
    cnt[col[x]]--;
    for(int i = 0;i < g[x].size();i++){
        int y = g[x][i];
        if(y == fa) continue;
        sub(y, x);
    }
}
void dfs2(int x, int fa, int opt){
    for(int i = 0;i < g[x].size();i++){
        int y = g[x][i];
        if(y == fa || y == son[x]) continue;
        dfs2(y, x, 0);
    }
    if(son[x]) dfs2(son[x],x,1);

    add(x, fa, son[x]);
    res[x] = sum;
    if(!opt) sub(x, fa), sum = mx = 0;
}
int main(){
    cin >> n;
    for(int i = 1;i <= n;i++){
        cin >> col[i];
    }
    for(int i = 1;i < n;i++){
        int u,v; cin >> u >> v;
        // addEdge(u, v);
        // addEdge(v, u);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs1(1, 0);
    dfs2(1, 0, 0);
    for(int i = 1;i <= n;i++){
        cout << res[i] << " ";
    }
    cout << endl;
    return 0;
}
```



## 点分治

### 关于点分治

首先，要学习点分树，首先要理解点分治的过程。

按照我的理解，点分治的过程在于：先处理当前树的答案，再选择当前树的重心，把它删掉，然后递归地处理剩下的子树。

这样做可以做到比较优秀的复杂度。

### 关于点分树

点分树可以看做是将整个点分治过程记录下来，将当前树的重心与上一层的树的重心连边（后者视作前者的父亲），这样就可以得到一个形态比较优秀的重构树，可以以比较优秀的复杂度解决不考虑树的形态的一类问题。

```c++
//https://www.luogu.com.cn/problem/P3806
#include <iostream>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;
const int N = 10005;
const int INF = 10000005;
int n,m,ask[N];
struct{
    int to,next,w;
}e[N<<1];
int head[N],idx;
void add(int u,int v, int w){
    e[++idx].to = v;
    e[idx].w = w;
    e[idx].next = head[u];
    head[u] = idx;
}
//
int del[N], siz[N], mxs, sum, root;
void getroot(int x, int fa){
    siz[x] = 1;
    int s = 0;
    for(int i = head[x];i;i = e[i].next){
        int y = e[i].to;
        if(y == fa || del[y]) continue;
        getroot(y, x);
        siz[x] += siz[y];
        s = max(s, siz[y]);
    }
    s = max(s, sum - siz[x]);
    if(s < mxs) mxs = s,root = x;
}
//
int dis[N],d[N],cnt;
void getdis(int x, int fa){
    dis[++cnt] = d[x];
    for(int i = head[x];i;i = e[i].next){
        int y = e[i].to;
        if(y == fa || del[y]) continue;
        d[y] = d[x] + e[i].w;
        getdis(y, x);
    }
}
//
int ans[N],q[INF],judge[INF];
void calc(int x){
    judge[0] = 1;
    int p = 0;
    for(int i = head[x];i;i = e[i].next){
        int y = e[i].to;
        if(del[y]) continue;
        // 求出子树v的各点到u的距离
        cnt = 0;
        d[y] = e[i].w;
        getdis(y, x);
        // 枚举距离和询问，判定答案
        for(int j = 1;j <= cnt;j++){
            for(int k = 1;k <= m;k++){
                if(ask[k] >= dis[j]){
                    ans[k] |= judge[ask[k] - dis[j]];
                }
            }
        }
        // 记录合法距离
        for(int j = 1;j <= cnt;j++){
            if(dis[j] < INF){
                q[++p] = dis[j],judge[q[p]] = 1;
            }
        }
    }
    // 清空距离数组
    for(int i = 1;i <= p;i++){
        judge[q[i]] = 0;
    }
}
void divide(int x){
    // 计算经过根u的路径
    calc(x);
    // 对u的子树进行分治
    del[x] = 1;
    for(int i = head[x];i;i = e[i].next){
        int y = e[i].to;
        if(del[y]) continue;
        mxs = sum = siz[y];
        getroot(y,0);// 求根
        divide(root);// 分治
    }
}
int main(){
    cin >> n >> m;
    for(int i = 1;i < n;i++){
        int u,v,w;
        cin >> u >> v >> w;
        add(u,v,w);
        add(v,u,w);
    }
    for(int i = 1;i <= m;i++){
        cin >> ask[i];
    }
    mxs = sum = n;
    getroot(1, 0);
    getroot(root, 0); // 重构siz[]
    divide(root);
    for(int i = 1;i <= m;i++){
        ans[i] ? puts("AYE") : puts("NAY");
    }
    return 0;
}
```



## 点分树

```c++
```



# 线段树

## 线段树模版

```c++
#include <iostream>
#define ll long long
using namespace std;
const int N = 100100;
ll n,m,p = __LONG_LONG_MAX__;
struct node{
    ll l,r;
    ll mlz, plz, sum;
} tree[N * 4];

int input[N];
void build(ll i, ll l, ll r){
    tree[i].l = l;
    tree[i].r = r;
    tree[i].mlz = 1;
    if(l == r){
        tree[i].sum = input[l] % p;
        return;
    }
    long long mid = (l + r) >> 1;
    build(i << 1, l, mid);
    build(i << 1|1, mid + 1, r);
    tree[i].sum = (tree[i<<1].sum + tree[i<<1|1].sum)%p;
    return;
}

inline void pushdown(long long i){
    long long k1=tree[i].mlz,k2=tree[i].plz;
    tree[i<<1].sum=(tree[i<<1].sum*k1+k2*(tree[i<<1].r-tree[i<<1].l+1))%p;
    tree[i<<1|1].sum=(tree[i<<1|1].sum*k1+k2*(tree[i<<1|1].r-tree[i<<1|1].l+1))%p;
    tree[i<<1].mlz=(tree[i<<1].mlz*k1)%p;
    tree[i<<1|1].mlz=(tree[i<<1|1].mlz*k1)%p;
    tree[i<<1].plz=(tree[i<<1].plz*k1+k2)%p;
    tree[i<<1|1].plz=(tree[i<<1|1].plz*k1+k2)%p;
    tree[i].plz=0;
    tree[i].mlz=1;
    return ;
}

inline void mul(long long i,long long l,long long r,long long k){
    if(tree[i].r<l || tree[i].l>r)  return ;
    if(tree[i].l>=l && tree[i].r<=r){
        tree[i].sum=(tree[i].sum*k)%p;
        tree[i].mlz=(tree[i].mlz*k)%p;
        tree[i].plz=(tree[i].plz*k)%p;
        return ;
    }
    pushdown(i);
    if(tree[i<<1].r>=l)  mul(i<<1,l,r,k);
    if(tree[i<<1|1].l<=r)  mul(i<<1|1,l,r,k);
    tree[i].sum=(tree[i<<1].sum+tree[i<<1|1].sum)%p;
    return ;
}

inline void add(ll i, ll l, ll r, ll k){
    if(tree[i].r < l || tree[i].l > r) return;
    if(tree[i].l >= l && tree[i].r <= r){
        tree[i].sum += ((tree[i].r - tree[i].l + 1) * k) % p;
        tree[i].plz = (tree[i].plz + k) % p;
        return;
    }
    pushdown(i);
    if(tree[i<<1].r >= l) add(i << 1, l , r, k);
    if(tree[i<<1|1].l <= r) add(i<<1|1,l,r,k);
    tree[i].sum = (tree[i<<1].sum + tree[i<<1|1].sum) % p;
    return;
}

inline ll search(ll i, ll l, ll r){
    if(tree[i].r < l || tree[i].l > r) return 0;
    if(tree[i].l>=l && tree[i].r<=r)
        return tree[i].sum;
    pushdown(i);
    long long sum=0;
    if(tree[i<<1].r>=l)  sum+=search(i<<1,l,r)%p;
    if(tree[i<<1|1].l<=r)  sum+=search(i<<1|1,l,r)%p;
    return sum%p;
}

int main(){
    cin >> n >> m;
    for(int i = 1; i<= n;i++){
        cin >> input[i];
    }
    build(1,1,n);
    for(int i = 1;i <= m;i++){
        ll fl,a,b,c;
        cin >> fl;
        if(fl == 1){
            cin >> a >> b >> c;
            add(1,a,b,c);
        }
        if(fl == 2){
            cin >> a >> b;
            cout << search(1,a,b) << endl;
        }
    }

    return 0;
}
```

## 主席树(可持久化线段树)

```c++
// https://www.luogu.com.cn/problem/P3919
#include <iostream>
#define ll long long
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
const ll N = 1000010;
ll n, m, a[N];
ll root[N], tot;
ll ls[N*25], rs[N*25], val[N*25];

struct{
    ll l,r;
    ll sum,add;
} tree[4*N];
#define lson k << 1
#define rson k << 1|1 

void build(ll &u, ll l, ll r){
    u = ++tot; // 动态开点
    if(l == r) {
        val[u] = a[l];
        return;
    }
    ll mid = (l + r) >> 1;
    build(ls[u], l, mid);
    build(rs[u], mid+1, r);
}

void change(ll &u, ll v, ll l, ll r, ll p, ll x){
    u = ++tot; // 动态开点
    ls[u] = ls[v];
    rs[u] = rs[v];
    val[u] = val[v];
    if(l == r){
        val[u] = x;
        return;
    }
    ll mid = (l + r) >> 1;
    if(p <= mid) change(ls[u], ls[v], l, mid, p, x);
    else change(rs[u], rs[v], mid+1, r, p , x);
}

ll query(ll u, ll l,ll r,ll p){
    if(l == r){
        return val[u];
    }
    ll mid = (l + r) >> 1;
    if(p <= mid) return query(ls[u],l,mid,p);
    else return query(rs[u],mid+1, r, p);
}

int main(){
    IOS
    cin >> n >> m;
    for(ll i = 1;i <= n;i++) cin >> a[i];
    build(root[0], 1, n);
    for(ll i = 1;i <= m;i++){
        ll ver,op,u,v; cin >> ver >> op;
        if(op == 1){
            cin >> u >> v;
            change(root[i], root[ver], 1, n, u , v);
        }else{
            cin >> u;
            root[i] = root[ver];
            cout << query(root[ver], 1, n, u) << endl;
        }
    }
}
```



## 普通平衡树(权值线段树)

```c++
// https://www.luogu.com.cn/problem/P3369
#include<iostream>
#include<algorithm>
#define ll long long
#define lson k << 1
#define rson k << 1|1
using namespace std;
const int N = 100010;
int n,m, a[N], b[N],opt[N];
int sum[N<<2];

void pushup(int k){
    sum[k] = sum[lson] + sum[rson];
}
void change(int k,int l, int r, int x, int val){ // point change
    if(l == r){
        sum[k] += val;
        return;
    }
    int mid = (l + r) >> 1;
    if(x <= mid) change(lson, l, mid, x, val);
    else change(rson, mid+1, r,x, val);
    pushup(k);
}
int queryRank(int k, int l, int r, int x, int y){ // 排名即 前缀和
    if(x <= l && y >= r) return sum[k];
    int mid = (l + r) >> 1;
    ll ans = 0;
    if(x <= mid) ans += queryRank(lson,l,mid,x,y);
    if(y > mid) ans += queryRank(rson, mid+1,r,x,y);
    return ans;
}
int queryNum(int k, int l,int r, int x){ // 排名x的数
    if(l == r) return l;
    int mid = (l + r) >> 1;
    if(x <= sum[lson]) return queryNum(lson,l,mid,x);
    else return queryNum(rson,mid+1,r,x - sum[lson]);
}
int main(){
    cin >> n;
    for(int i = 1; i <= n;i++){
        cin >> opt[i] >> a[i];
        if(opt[i] != 4)
            b[++m] = a[i];
    }
    sort(b + 1, b + 1 + m);
    m = unique(b + 1, b + 1 + m) - b - 1;
    for(int i = 1;i <= n;i++){
        int id;
        if(opt[i] != 4) id = lower_bound(b+1,b+m+1,a[i]) - b;
        if(opt[i] == 1){ // 插入
            change(1, 1, m, id, 1);
        }
        if(opt[i] == 2){ // 删除
            change(1, 1, m, id, -1);
        }
        if(opt[i] == 3){ // x的排名
            cout << (id > 1 ? queryRank(1,1,m,1,id-1) + 1 : 1) << endl;
        }
        if(opt[i] == 4){ // 排名为x的数
            cout << b[queryNum(1,1,m,a[i])] << endl;
        }
        if(opt[i] == 5){ // x 前驱
            int rk = queryRank(1,1,m,1,id-1);
            cout << b[queryNum(1,1,m,rk)] << endl;
        }
        if(opt[i] == 6){
            int rk = queryRank(1,1,m,1,id) + 1;
            cout << b[queryNum(1,1,m,rk)] << endl;
        }
    }
}
```

## 普通平衡树(splay)

```c++
#include <iostream>
using namespace std;

#define ls(x) tr[x].s[0]
#define rs(x) tr[x].s[1]
const int N=1100010, INF=(1<<30)+1;
struct node{
  int s[2]; //左右儿子
  int p; //父亲
  int v; //节点权值
  int cnt; //权值出现次数
  int siz; //子树大小
  void init(int p1,int v1){
    p=p1, v=v1;
    cnt=siz=1;
  }
}tr[N];
int root; //根节点编号
int idx; //节点个数

void pushup(int x){
  tr[x].siz=tr[ls(x)].siz+tr[rs(x)].siz+tr[x].cnt;
}
void rotate(int x){
  int y=tr[x].p, z=tr[y].p;
  int k = tr[y].s[1]==x;
  tr[z].s[tr[z].s[1]==y] =x;
  tr[x].p = z;  
  tr[y].s[k] = tr[x].s[k^1];
  tr[tr[x].s[k^1]].p = y;
  tr[x].s[k^1] = y;
  tr[y].p = x;
  pushup(y), pushup(x);
}
void splay(int x, int k){
  while(tr[x].p!=k){
    int y=tr[x].p, z=tr[y].p;
    if(z!=k)   // 折转底，直转中
      (ls(y)==x)^(ls(z)==y)
        ? rotate(x) : rotate(y);
    rotate(x);
  }
  if(!k) root=x;
}
void insert(int v){ //插入
  int x=root, p=0;
  while(x && tr[x].v!=v)
    p=x, x=tr[x].s[v>tr[x].v];
  if(x) tr[x].cnt++;
  else{
    x=++idx;
    if(p) tr[p].s[v>tr[p].v]=x;
    tr[x].init(p,v);
  }
  splay(x, 0);
}
void find(int v){ //找到v并转到根
  int x=root;
  while(tr[x].s[v>tr[x].v]&&v!=tr[x].v) 
    x=tr[x].s[v>tr[x].v]; 
  splay(x, 0);
}
int getpre(int v){ //前驱
  find(v);
  int x=root;
  if(tr[x].v<v) return x;
  x=ls(x);
  while(rs(x)) x=rs(x);
  splay(x, 0);
  return x;
}
int getsuc(int v){ //后继
  find(v);
  int x=root;
  if(tr[x].v>v) return x;
  x=rs(x);
  while(ls(x)) x=ls(x);
  splay(x, 0);
  return x;
}
void del(int v){ //删除
  int pre=getpre(v);
  int suc=getsuc(v);
  splay(pre,0), splay(suc,pre);
  int del=tr[suc].s[0];
  if(tr[del].cnt>1)
    tr[del].cnt--, splay(del,0);
  else
    tr[suc].s[0]=0, splay(suc,0);
}
int getrank(int v){ //排名
  insert(v);
  int res=tr[tr[root].s[0]].siz;
  del(v);
  return res;
}
int getval(int k){ //数值
    int x=root;
    while(true){
        if(k<=tr[ls(x)].siz) x=ls(x);
        else if(k<=tr[ls(x)].siz+tr[x].cnt) break;
        else k-=tr[ls(x)].siz+tr[x].cnt, x=rs(x);
    }
    splay(x, 0);
    return tr[x].v;
}
int main(){
  insert(-INF);insert(INF); //哨兵
  int n;
  cin >> n;
  while(n--){
    int op,x; cin >> op >> x;
    if(op==1) insert(x);
    if(op==2) del(x);
    if(op==3) cout << getrank(x) << endl;
    if(op==4) cout << getval(x+1) << endl;
    if(op==5) cout << tr[getpre(x)].v << endl;
    if(op==6) cout << tr[getsuc(x)].v << endl;
  }
  return 0;
}
```



## 普通平衡树(Treap)

```c++
#include <iostream>
using namespace std;

const int N = 100005;
struct node
{
    int l, r; // 左右儿子
    int val;  // 树的权值
    int rnd;  // 堆的随机值
    int size; // 子树大小
} tr[N];
int root, idx;

void newnode(int &x, int v)
{
    x = ++idx;
    tr[x].val = v;
    tr[x].rnd = rand();
    tr[x].size = 1;
}
void pushup(int p)
{
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + 1;
}
void split(int p, int v, int &x, int &y)
{
    if (!p)
    {
        x = y = 0;
        return;
    }
    if (tr[p].val <= v)
    {
        x = p;
        split(tr[x].r, v, tr[x].r, y);
        pushup(x);
    }
    else
    {
        y = p;
        split(tr[y].l, v, x, tr[y].l);
        pushup(y);
    }
}
int merge(int x, int y)
{
    if (!x || !y)
        return x + y;
    if (tr[x].rnd < tr[y].rnd)
    {
        tr[x].r = merge(tr[x].r, y);
        pushup(x);
        return x;
    }
    else
    {
        tr[y].l = merge(x, tr[y].l);
        pushup(y);
        return y;
    }
}
void insert(int v)
{
    int x, y, z;
    split(root, v, x, y);
    newnode(z, v);
    root = merge(merge(x, z), y);
}
void del(int v)
{
    int x, y, z;
    split(root, v, x, z);
    split(x, v - 1, x, y);
    y = merge(tr[y].l, tr[y].r);
    root = merge(merge(x, y), z);
}
int getrank(int v)
{
    int x, y;
    split(root, v - 1, x, y);
    int ans = tr[x].size + 1;
    root = merge(x, y);
    return ans;
}
int getval(int root, int v)
{
    if (v == tr[tr[root].l].size + 1)
        return tr[root].val;
    else if (v <= tr[tr[root].l].size)
        return getval(tr[root].l, v);
    else
        return getval(tr[root].r, v - tr[tr[root].l].size - 1);
}
int getpre(int v)
{
    int x, y, s, ans;
    split(root, v - 1, x, y);
    s = tr[x].size;
    ans = getval(x, s);
    root = merge(x, y);
    return ans;
}
int getnxt(int v)
{
    int x, y, ans;
    split(root, v, x, y);
    ans = getval(y, 1);
    root = merge(x, y);
    return ans;
}
int main()
{
    int n, op, v;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d%d", &op, &v);
        if (op == 1)
            insert(v);
        else if (op == 2)
            del(v);
        else if (op == 3)
            printf("%d\n", getrank(v));
        else if (op == 4)
            printf("%d\n", getval(root, v));
        else if (op == 5)
            printf("%d\n", getpre(v));
        else
            printf("%d\n", getnxt(v));
    }
    return 0;
}
```

## 线段树合并(树上差分)

```c++
// https://www.luogu.com.cn/problem/P4556
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#define mid ((l + r) >> 1)
using namespace std;
const int N = 100005;
int n,m, res[N];
vector<int> g[N];
int fa[N][20], dep[N];
int root[N], tot;
int ls[N*50],rs[N*50],sum[N*50],typ[N*50];
void dfs(int x, int f){
    dep[x] = dep[f] + 1;
    fa[x][0] = f;
    for(int i = 1;i <= 18;i++){
        fa[x][i] = fa[fa[x][i-1]][i-1];
    }
    for(int i = 0;i < g[x].size();i++){
        int y = g[x][i];
        if(y != f)
            dfs(y, x);
    }
}
int lca(int x, int y){
    if(dep[x] < dep[y]) swap(x, y);
    for(int i = 18;~i;i--){
        if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
    }
    if(x == y) return y;
    for(int i = 18;~i;i--){
        if(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
    }
    return fa[x][0];
}
void pushup(int u){
    if(sum[ls[u]] >= sum[rs[u]]){
        sum[u]=sum[ls[u]];
        typ[u]=typ[ls[u]];
    }else{
        sum[u]=sum[rs[u]];
        typ[u]=typ[rs[u]];
    }
}
void change(int &u, int l,int r,int p,int k){
    if(!u) u = ++tot;
    if(l==r){
        sum[u] += k;
        typ[u] = p;
        return ;
    }
    if(p <= mid) change(ls[u], l, mid, p, k);
    else change(rs[u],mid+1,r,p,k);
    pushup(u);
}
int merge(int x, int y, int l, int r){
    if(!x || !y) return x + y;
    if(l == r){
        sum[x] += sum[y];
        return x;
    }
    ls[x] = merge(ls[x],ls[y],l,mid);
    rs[x] = merge(rs[x],rs[y],mid+1,r);
    pushup(x);
    return x;
}
void dfs2(int x, int f){
    for(int i = 0;i < g[x].size();i++){
        int y = g[x][i];
        if(y == f) continue;
        dfs2(y,x);
        root[x] = merge(root[x], root[y],1, N);
    }
    res[x] = sum[root[x]] ? typ[root[x]] : 0;
}
int main(){
    cin >> n >> m;
    for(int i = 1,x,y;i < n;i++){
        cin >> x >> y;
        g[x].push_back(y);
        g[y].push_back(x);
    }
    dfs(1,0);
    for(int i = 1,x,y,z;i <= m;i++){
        cin >> x >> y >> z;
        change(root[x],1,N,z,1);
        change(root[y],1,N,z,1);
        int t=lca(x,y);
        change(root[t],1,N,z,-1);
        change(root[fa[t][0]],1,N,z,-1);
    }
    dfs2(1,0); 
    for(int i = 1;i<=n;i++){
        cout << res[i] << endl;
    }
    return 0;
}
```



## 线段树分裂

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

#define ll long long
#define mid ((l+r)>>1)
const int N=200005;
int n,m,tot,root[N];
int ls[N*22],rs[N*22]; ll sum[N*22]; //权值个数

int merge(int x,int y){ //合并
  if(!x||!y) return x+y;
  sum[x]+=sum[y];
  ls[x]=merge(ls[x],ls[y]);
  rs[x]=merge(rs[x],rs[y]);
  return x;
}
void split(int x,int &y,ll k){ //分裂
  //将x从k处斩断，前k小的归x，后面的归y
  if(sum[x]==k) return;
  y=++tot; //开点
  ll s=sum[ls[x]];
  //swap:右子树归y，x的右子树变成0
  if(k<=s) split(ls[x],ls[y],k),swap(rs[x],rs[y]);
  else split(rs[x],rs[y],k-s);
  sum[y]=sum[x]-k; sum[x]=k;
}
void change(int &u,int l,int r,int p,int k){ //点修
  if(!u) u=++tot; //开点
  sum[u]+=k;
  if(l==r) return;
  if(p<=mid) change(ls[u],l,mid,p,k);
  else change(rs[u],mid+1,r,p,k);
}
ll query(int u,int l,int r,int x,int y){ //区查
  if(x>r||y<l) return 0;
  if(x<=l&&r<=y) return sum[u];
  return query(ls[u],l,mid,x,y)+query(rs[u],mid+1,r,x,y);
}
int kth(int u,int l,int r,int k){ //第k小
  if(l==r) return l;
  if(k<=sum[ls[u]]) return kth(ls[u],l,mid,k);
  else return kth(rs[u],mid+1,r,k-sum[ls[u]]);
}
int main(){
  scanf("%d%d",&n,&m);int op,p,x,y,cnt=1;
  for(int i=1;i<=n;i++)
    scanf("%d",&x),change(root[1],1,n,i,x);
  for(int i=1;i<=m;i++){
    scanf("%d",&op);
    if(op==0){ //[x,y]移动到新可重集cnt
      scanf("%d%d%d",&p,&x,&y);
      ll k1=query(root[p],1,n,1,y), //[1,y]的个数
         k2=query(root[p],1,n,x,y); //[x,y]的个数
      int tmp=0;
      split(root[p],root[++cnt],k1-k2);
      split(root[cnt],tmp,k2);
      root[p]=merge(root[p],tmp);
    }
    else if(op==1){ //可重集y放入x
      scanf("%d%d",&x,&y);
      root[x]=merge(root[x],root[y]);
    }
    else if(op==2){ //加入x个数字y
      scanf("%d%d%d",&p,&x,&y);
      change(root[p],1,n,y,x);
    }
    else if(op==3){ //查询[x,y]个数
      scanf("%d%d%d",&p,&x,&y);
      printf("%lld\n",query(root[p],1,n,x,y));
    }
    else{ //查询第x小
      scanf("%d%d",&p,&x);
      if(sum[root[p]]<x) printf("-1\n");
      else printf("%d\n",kth(root[p],1,n,x));
    }
  }
}
```



## 树套树(线段树套平衡树)

```c++
#include <iostream>
#include <algorithm>
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define lson k << 1
#define rson k << 1 | 1
#define ls(x) tr[x].s[0]
#define rs(x) tr[x].s[1]
#define ll long long
#define INF 2147483647
#define endl "\n"
using namespace std;
const int N = 50005;
ll n,m,w[N];
// splay
int idx;
struct{
    int s[2];
    ll p, val, cnt, size;
    void init(ll _p, ll _val){
        p = _p;
        val = _val;
        cnt = size = 1;
    }
} tr[N * 40];
inline void pushup(int x){
    tr[x].size = tr[ls(x)].size + tr[rs(x)].size + tr[x].cnt;
}
inline void rotate(int x){
    int y = tr[x].p;
    int z = tr[y].p;
    int k = rs(y) == x;
    tr[z].s[rs(z) == y] = x;
    tr[x].p = z;
    tr[y].s[k] = tr[x].s[k^1];
    tr[tr[x].s[k^1]] .p = y;
    tr[x].s[k^1] = y;
    tr[y].p = x;
    pushup(y);
    pushup(x);
}
inline void splay(int &root, int x, int k){
    while(tr[x].p != k){
        int y = tr[x].p;
        int z = tr[y].p;
        if(z != k){
            (ls(y) == x) ^ (ls(z) == y) ? rotate(x) : rotate(y);
        }
        rotate(x);
    }
    if(!k) root = x;
}
inline void insert(int &root,int v){
  int u=root,p=0;
  while(u) p=u,u=tr[u].s[v>tr[u].val];
  u = ++idx;
  tr[p].s[v>tr[p].val]=u;
  tr[u].init(p,v);
  splay(root,u,0);
}
inline void del(int &root, int v){
    int u = root;
    while(u){
        if(tr[u].val == v) break;
        if(tr[u].val < v) u = rs(u);
        else u = ls(u);
    }
    splay(root, u, 0);
    int l = ls(u), r = rs(u);
    while(rs(l)) l = rs(l);
    while(ls(r)) r = ls(r);
    splay(root, l, 0);
    splay(root, r, l);
    ls(r) = 0;
    splay(root, r , 0);
}
inline int getRank(int root, int v){
    int u = root, res = 0;
    while(u){
        if(tr[u].val < v){
            res+=tr[ls(u)].size+1;
            u = rs(u);
        }
        else u = ls(u);
    }
    return res;
}
inline int getPre(int root, int v){
    int u = root, res = -INF;
    while(u){
        if(tr[u].val < v){
            res = tr[u].val;
            u = rs(u);
        }
        else u = ls(u);
    }
    return res;
}
inline int getNxt(int root, int v){
    int u = root, res = INF;
    while(u){
        if(tr[u].val > v){
            res = tr[u].val;
            u = ls(u);
        }
        else u = rs(u);
    }
    return res;
}
//xianduanshu
int root[N * 4];
inline void build(int k, int l, int r){
    insert(root[k], -INF);
    insert(root[k], INF);
    for(int i = l; i <= r; i++) insert(root[k], w[i]);
    if(l == r) return ;
    int mid = (l + r) >> 1;
    build(lson, l, mid);
    build(rson, mid+1, r);
}
inline int queryRank(int k, int l, int r, int x, int y, int v){
    if(x <= l && y >= r) return getRank(root[k], v) - 1;
    int mid = (l + r) >> 1;
    ll res = 0;
    if(x <= mid) res += queryRank(lson, l , mid, x, y, v);
    if(y > mid) res += queryRank(rson, mid+1, r, x, y, v);
    return res;
}
inline int queryVal(int k, int x, int y, int v){
    int l = 0, r = 1e8, res;
    while(l <= r){
        int mid = (l + r) >> 1;
        if(queryRank(1,1,n,x,y,mid) + 1 <= v) 
            l=mid+1, res=mid;
        else r = mid - 1;
    }
    return res;
}
inline void change(int k,int l,int r,int pos,int v){
  del(root[k],w[pos]);
  insert(root[k],v);
  if(l==r) return;
  int mid=(l+r)>>1;
  if(pos<=mid) change(lson,l,mid,pos,v);
  else change(rson,mid+1,r,pos,v);
}
inline int querypre(int k,int l,int r,int x,int y,int v){
  if(x<=l && r<=y) return getPre(root[k],v);
  int mid=(l+r)>>1, res=-INF;
  if(x<=mid) res=max(res,querypre(lson,l,mid,x,y,v));
  if(y>mid) res=max(res,querypre(rson,mid+1,r,x,y,v));
  return res;
}
inline int querynxt(int k,int l,int r,int x,int y,int v){
  if(x<=l && r<=y) return getNxt(root[k],v);
  int mid=(l+r)>>1, res=INF;
  if(x<=mid) res=min(res,querynxt(lson,l,mid,x,y,v));
  if(y>mid) res=min(res,querynxt(rson,mid+1,r,x,y,v));
  return res;
}
int main(){
    IOS
    cin >> n >> m;
    for(int i = 1; i <= n;i++) cin >> w[i];
    build(1,1,n);
    while(m--){
        int op,l,r,v; cin >> op >> l >> r;
        if(op != 3) cin >> v;
        if(op == 1) cout << queryRank(1,1,n,l,r,v) + 1 << endl;
        if(op == 2) cout << queryVal(1,l,r,v) << endl;
        if(op == 3) change(1,1,n,l,r), w[l] = r;
        if(op == 4) cout << querypre(1,1,n,l,r,v) << endl;
        if(op == 5) cout << querynxt(1,1,n,l,r,v) << endl;
    }
    return 0;
}
```



## 莫队

```c++
// https://www.luogu.com.cn/problem/P2709
#include <math.h>
#include <iostream>
#include <algorithm>
#define endl "\n"
#define ll long long
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
using namespace std;
const int N = 50101;
ll res, n, m, k, a[N], cnt[N], pos[N],ans[N];

struct Q{
    int id, l, r;
    const bool operator<(Q a) const {
        return pos[l] == pos[a.l] ? pos[r] < pos[a.r] : pos[l] < pos[a.l];
    }
} q[N];
inline void add(int x){
    ++cnt[a[x]];
	res += pow(cnt[a[x]], 2) - pow(cnt[a[x]] - 1, 2);
}
inline void sub(int x){
    --cnt[a[x]];    
	res -= pow(cnt[a[x]] + 1, 2) - pow(cnt[a[x]], 2);
}
int main(){
    IOS
    cin >> n >> m >> k;
    // int size = max(1, sqrt(n));
    int size = sqrt(n);
    for(int i = 1;i <= n;i++){
        cin >> a[i];
        pos[i] = i / size;
    }
    for(int i = 1;i <= m;i++){
        int l,r; cin >> l >> r;
        q[i] = (Q){i,l,r};
    }
    sort(q+1, q+1+m);
    for(int i = 1,l = 1,r = 0;i <= m;i++){
        while(q[i].l < l) add(--l); 
        while(q[i].r > r) add(++r);
        while(q[i].l > l) sub(l++);
        while(q[i].r < r) sub(r--);
        ans[q[i].id] = res;
    }
    for(int i = 1;i <= m;i++){
        cout << ans[i] << endl;
    }
    return 0;
}
```

## 1

![image-20231109202656156](/Users/dahuang/Library/Application Support/typora-user-images/image-20231109202656156.png)

```c++
#include <iostream>
#include <algorithm>
#include <math.h>
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define endl "\n"
#define ll long long
using namespace std;
const int N = 1200010;
ll n,m,k,res, a[N], cnt[N], pos[N], ans[N];
struct node{
    int id, l, r;
    const bool operator<(node a)const {
        return pos[l] == pos[a.l] ? pos[r] < pos[a.r] : pos[l] < pos[a.l];
    }
} q[N];
inline void add(int x){
    res+=(ll)cnt[a[x]^k];
    cnt[a[x]]++;
}
inline void sub(int x){
    cnt[a[x]]--;
    res-=(ll)cnt[a[x]^k];
}
int main(){ // 
    IOS
    cin >> n >> m >> k;
    int size = sqrt(n);
    for(int i = 1;i <= n;i++){
        cin >> a[i];
        a[i]^=a[i-1];
        pos[i] = (i-1) / size + 1;
    }
    for(int i = 1;i <= m;i++){
        int u,v; cin >> u >> v;
        u--;
        q[i] = (node){i,u,v};
    }
    sort(q+1, q+1+m);
    for(int i = 1, l = 1, r = 0;i <= m; i++){
        while(q[i].l < l) add(--l);
        while(q[i].r > r) add(++r);
        while(q[i].l > l) sub(l++);
        while(q[i].r < r) sub(r--);
        ans[q[i].id] = res;
    }
    for(int i = 1;i <= m; i++){
        cout << ans[i] << endl;
    }
    return 0;
}
```

## 带修莫队

```c++
#include <iostream>
#include <math.h>
#include <algorithm>
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
#define endl "\n"
#define ll long long
using namespace std;
const int N = 1333333;
ll res;
int n,m, a[N], cnt[N], pos[N],cntr,cntq, ans[N];
struct node{
    int id,t,l,r;
    const bool operator<(node a) const{
        return pos[l] == pos[a.l] ? pos[r] == pos[a.r] ? t < a.t : r < a.r : l < a.l;
    }
} qq[N], qr[N];
inline void add(int x)
{
	res += !cnt[x]++;
}

inline void sub(int x)
{
	res -= !--cnt[x];
}
inline void upd(int x, int t)//upd是对于时间上的变化所造成变化的维护
{
	if (qq[x].l <= qr[t].l && qr[t].l <= qq[x].r)
	{
		sub(a[qr[t].l]);
		add(qr[t].r);
	} //如果这个修改的值在[l,r]区间内，则其变化将对答案造成影响
	swap(a[qr[t].l], qr[t].r);//因为修改后的下一次操作一定相反(即修改该位置->还原该位置->修改该位置...如此循环)，所以只需交换即可，而不需要写两个函数
}

int main(){
    IOS
    cin >> n >> m;
    int size = pow(n, 0.666);
    for(int i = 1; i <= n;i++){
        cin >> a[i];
        pos[i] = i / size;
    }
    for(int i = 1;i <= m;i++){
        char ch; int l,r; cin >> ch >> l >> r;
        if(ch == 'Q')++cntq, qq[cntq].id = cntq, qq[cntq].l = l, qq[cntq].r = r, qq[cntq].t = cntr;//询问的时间即为该询问以前已经执行了多少次修改操作
        else qr[++cntr].l = l, qr[cntr].r = r;
    }
    sort(qq + 1, qq + cntq + 1);
    for(int i = 1,l = 1,r = 0,t = 0; i <= cntq; i++){
        while (l > qq[i].l) add(a[--l]);
		while (l < qq[i].l) sub(a[l++]);
		while (r > qq[i].r) sub(a[r--]);
		while (r < qq[i].r) add(a[++r]);
		while (t < qq[i].t) upd(i, ++t);
		while (t > qq[i].t) upd(i, t--);//增加t轴上的移动
		ans[qq[i].id] = res;//得到最终答案
    }
    for(int i = 1;i <= cntq;i++){
        cout << ans[i] << endl;
    }
    return 0;
}
```

# 动态规划

## 状态压缩

```c++
#include <iostream>
#define ll long long
using namespace std;
int n, k;
int cnt;
int s[1 << 12];   // 同一行合法状态集
int num[1 << 12]; // 每个合法状态的国王数
ll f[12][144][1 << 12];
// f i j a 前i行放了j个国王 第i行第a个状态时的方案数
int main()
{
    cin >> n >> k;
    for (int i = 0; i < (1 << n); i++) // 枚举一行的所有状态
        if (!(i & i >> 1))
        {                 // 如果不存在相邻的1
            s[cnt++] = i; // 一行的合法状态集，例101
            for (int j = 0; j < n; j++)
                num[i] += (i >> j & 1); // 每个合法状态包含的国王数
        }
    
    f[0][0][0] = 1;
    for (int i = 1; i <= n + 1; i++)          // 枚举行
        for (int j = 0; j <= k; j++)          // 枚举国王数
            for (int a = 0; a < cnt; a++)     // 枚举第i行的合法状态
                for (int b = 0; b < cnt; b++) // 枚举第i-1行的合法状态
                {
                    int c = num[s[a]];           // 第i行第a个状态的国王数
                    if ((j >= c)                 // 可以继续放国王
                        && !(s[b] & s[a])        // 不存在同列的1
                        && !(s[b] & (s[a] << 1)) // 不存在斜对角的1
                        && !(s[b] & (s[a] >> 1)))
                        f[i][j][a] += f[i - 1][j - c][b]; // 行间转移
                }
    cout << f[n + 1][k][0] << endl;
    return 0;
}
```

```c++
//https://www.luogu.com.cn/problem/P1879
#include <iostream>
#define ll long long
using namespace std;

int n,m, cnt;
int s[1 << 14];
int g[14];
ll f[14][1 << 14];
ll MOD = 1e8;
int main(){
    cin >> n >> m;
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            int x; cin >> x;
            g[i] = (g[i] << 1) + x;
        }
    }
    for(int i = 0;i < (1 << m);i++){
        if(!(i & i >> 1)){
            s[cnt++] = i;
        }
    }
    f[0][0] = 1;
    for(int i = 1; i <= n + 1; i++){
        for(int a = 0; a < cnt;a++){
            for(int b = 0; b < cnt; b++){
                if((s[a] & g[i]) == s[a] && !(s[a]&s[b])){
                    f[i][a] = (f[i-1][b] + f[i][a]) % MOD;
                }
            }
        }
    }
    cout << f[n+1][0] << endl;
    return 0;
}
```

```c++
// https://www.luogu.com.cn/problem/P2704
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 110, M = 1 << 10;
int n, m;       // 行数,列数
int g[N];       // 存储地图各行数值
int cnt;        // 一行的合法状态个数
int s[M];       // 一行的合法状态集
int num[M];     // 每个合法状态包含1的个数
int f[N][M][M]; // 110*1024*1024*4 = 440MB
// f[i][a][b]表示已放好前i行，
// 第i行第a个状态，第i-1行第b个状态时，能放置的最大数量

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < m; j++)
        {
            char c;
            cin >> c;
            if (c == 'P')
                g[i] += 1 << (m - j - 1); // 地图各行数值
        }

    for (int i = 0; i < (1 << m); i++) // 枚举一行的所有状态
        if (!(i & i >> 1) && !(i & i >> 2))
        {                 // 如果不存在11和101
            s[cnt++] = i; // 保存一行的合法状态
            for (int j = 0; j < m; j++)
                num[i] += (i >> j & 1); // 每个合法状态包含1的个数
        }

    for (int i = 1; i <= n + 2; i++)          // 枚举行
        for (int a = 0; a < cnt; a++)         // 枚举第i行合法状态
            for (int b = 0; b < cnt; b++)     // 枚举第i-1行合法状态
                for (int c = 0; c < cnt; c++) // 枚举第i-2行合法状态
                    if (!(s[a] & s[b]) && !(s[a] & s[c]) && !(s[b] & s[c]) && (g[i] & s[a]) == s[a] && (g[i - 1] & s[b]) == s[b])
                        f[i][a][b] = max(f[i][a][b], f[i - 1][b][c] + num[s[a]]);

    cout << f[n + 2][0][0] << endl;
    return 0;
}
```

## 最长上升子序列 ( Dilworth 定理)

```c++
// https://www.luogu.com.cn/problem/P1020
#include <algorithm>
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int dp1[N],dp2[N], cnt1 = 1, cnt2 = 1;
int a[N], cnt, res, num;

int main(){ // Dilworth 定理
    int x;
    while(cin >> x){
        a[++cnt] = x;
    }
    dp1[1]=a[1],dp2[1]=a[1];
    for(int i = 2;i <= cnt;i++){
        if(a[i] <= dp1[cnt1]){
			dp1[++cnt1] = a[i];
		}
        else{
            int k1 = upper_bound(dp1+1,dp1+cnt1+1,a[i],greater<int>()) - dp1;
            dp1[k1] = a[i];
        }
        if(a[i]>dp2[cnt2]){
            dp2[++cnt2] = a[i];
        }else{
            int k2 = lower_bound(dp2+1, dp2+cnt2+1, a[i]) - dp2;
            dp2[k2] = a[i];
        }
    }
    cout << cnt1 << endl << cnt2 << endl;

    return 0;
}
```

## 单调队列优化dp

```c++
// https://www.luogu.com.cn/problem/P1725
#include <iostream>
#include <algorithm>
#include <deque>
#include <cstring>
using namespace std;
const int N = 1000010;
int n,l,r;
int f[N],a[N],res = -2e9;
deque<int> q;
int main(){
    cin >> n >> l >> r;
    for(int i = 0;i <= n;i++){
        cin >> a[i];
    }
    memset(f, -0x3f, sizeof f);
    f[0] = 0;
    for(int i = l; i <= n;i++){
        while(!q.empty() && f[q.back()] <= f[i - l]) q.pop_back();
        q.push_back(i - l);
        if(q.front() < i - r) q.pop_front();
        f[i] = f[q.front()] + a[i];
        if(i > n - r) res = max(res, f[i]);
    }
    cout << res << endl;
    return 0;
}
```

> 最短距离

```c++
//https://www.luogu.com.cn/problem/P2758
#include <algorithm>
#include <iostream>
#include <string>
using namespace std;
const int N = 10000;
string a,b;
int dp[N][N];
int main(){ // （最短距离）
    cin >> a >> b;
    for(int i = 1;i <= a.size(); i++){
        dp[i][0] = i;
    }
    for(int i = 1;i <= b.size(); i++){
        dp[0][i] = i;
    }
    for(int i = 1; i <= a.size(); i++){
        for(int j = 1; j <= b.size(); j++){
            if(a[i - 1] == b[j - 1]){
                dp[i][j] = dp[i-1][j-1];
                continue;
            }
            dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
        }
    }
    cout << dp[a.size()][b.size()] << endl;
    return 0;
}
```

```c++
//最短Hamilton路径 https://www.acwing.com/problem/content/93/
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 20, M = 1 << N;
int n;
int f[M][N],g[N][N];
int main(){
    cin >> n;
    for(int i = 0;i < n;i++){
        for(int j = 0; j < n;j++){
            cin >> g[i][j];
        }
    }
    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;
    for(int i = 0; i < 1 << n;i++){
        for(int j = 0; j < n;j++){
            if(i >> j & 1){
                for(int k = 0; k < n;k++){
                    if(i >> k&1){
                        f[i][j] = min(f[i][j],  f[i - (1 << j)][k] + g[k][j]); 
                    }
                }
            }
        }
    }
    // for(int i = 0;i < n;i++){
    //     for(int j = 0; j < n;j++){
    //         cout << f[i][j] << " ";
    //     }
    //     cout << endl;
    // }
    cout << f[(1 << n) - 1][n-1] << endl;
    return 0;
}
```

