# 分布式系统

## 幂等性

幂等性（Idempotence）是一个重要的概念，它指的是一个操作或函数多次执行的结果与执行一次的结果相同。换句话说，无论这个操作执行多少次，系统的状态都保持不变，或者最终结果都是一样的。

幂等在分布式系统中十分重要，这主要是因为：

- 可靠性：在分布式系统中，网络延迟或故障可能导致请求被重复发送。幂等操作可以确保即使请求被重复执行，系统状态也不会出错。
- 简化逻辑：幂等性可以简化错误处理和重试逻辑，因为不需要担心重复执行带来的副作用。
- 一致性：在并发环境下，幂等操作有助于保持系统的一致性。

正常来说，在分布式环境下，重试 + 幂等是保证业务成功的重要手段。

场景

1. 表单提交，通过要求表单带上一个唯一标识符，可以解决表单重复提交的问题，例如说在电商里面非常重要的重复创建订单问题。
2. 消费者幂等。实践中我会要求我的同事，要尽可能将消费者设计为幂等，而后叠加重试，可以确保消息一定会被消费，并且至多被消费一次。
3. 微服务调用，通过重试加接口幂等的措施，来保证业务的可靠性。

应该说，在整个分布式系统中，大多数的可用性问题、一致性问题和业务可靠性问题，基本上都可以通过重试加幂等来解决。如果要是重试之后都失败了，那就只能考虑手工介入了。

> 表单重复提交；消费者幂等；重试+幂等

## 如何实现幂等性

幂等的意思是，同一个请求执行多次的结果是一样。大多数时候，幂等是通过拒绝多次执行来达成的。

**1. 利用唯一索引来保证幂等**

基本原理：

- 通过在数据库表中设置唯一索引（如订单号、用户ID等），确保每次插入或更新操作都不会产生重复的数据。
- 当尝试插入重复数据时，数据库会抛出唯一性约束异常，系统可以捕获该异常并进行相应处理。

优点：

- 实现简单，直接利用数据库的特性。
- 保证数据的一致性和唯一性。

缺点：

- 依赖于数据库的性能，在高并发情况下可能会成为瓶颈。
- 异常处理逻辑需要谨慎设计，避免影响用户体验。

**2. 利用 Redis 来保证幂等**

基本原理：

- 利用 Redis 的键值存储特性，在执行操作前先在 Redis 中检查是否存在特定的键。
- 如果键已存在，则认为是重复操作，直接返回或忽略。
- 如果键不存在，则认为可以执行，并且写入 Redis。这个过程要注意操作顺序和部分失败的问题。

优点：

- Redis 的读写性能极高，适合高并发场景。
- 可以灵活设置键的过期时间，避免长时间占用存储空间。

缺点：

- 需要额外的存储资源和管理成本。
- 在分布式环境下，需要考虑 Redis 的集群和高可用性。
- Redis 宕机之后数据丢失

**3. 利用 Redis 和唯一索引来保证幂等**

基本原理：

- 结合 Redis 的高性能和数据库的唯一索引特性，先在 Redis 中进行幂等性检查，再在数据库中执行操作。
- Redis 用于快速判断是否为重复请求，数据库唯一索引作为最终保障。

优点：

- 兼具 Redis 的高性能和数据库的可靠性。
- 多层次保障，提高系统的健壮性。

缺点：

- 实现复杂度较高，需要维护两套系统。
- 成本较高，需要同时管理 Redis 和数据库。

**4. 利用布隆过滤器和唯一索引来保证幂等**

基本原理：

- 布隆过滤器用于快速判断元素是否可能存在于集合中，先通过布隆过滤器进行初步检查。
- 如果布隆过滤器判断为不存在，再进行数据库操作，并利用唯一索引确保数据唯一性。

优点：

- 布隆过滤器占用空间小，查询速度快。
- 减少对数据库的访问，降低数据库压力。

缺点：

- 布隆过滤器有误判率，可能将不存在的元素误判为存在。
- 需要定期维护布隆过滤器，避免数据溢出。

**5. 利用布隆过滤器 + Redis + 唯一索引来保证幂等**

基本原理：

- 结合布隆过滤器、Redis 和数据库唯一索引的多重保障机制。
- 先通过布隆过滤器进行初步检查，再通过 Redis 进行二次确认，最后在数据库中执行操作并利用唯一索引确保数据唯一性。

优点：

- 多层次防护，极大提高幂等性的可靠性。
- 充分利用各技术的优势，兼顾性能和可靠性。

缺点：

- 实现复杂度极高，维护成本大。
- 系统架构复杂，需要考虑各组件的协同和高可用性。

## 分布式锁

分布式锁是一种在分布式系统中用于控制多个进程或线程对共享资源进行互斥访问的机制。简单来说，它确保在分布式环境下，同一时间只有一个进程或线程能够操作某个共享资源，从而避免数据不一致或资源冲突的问题。

其实就是一个运作在分布式环境下的锁。

使用分布式锁只有一个原因：排它性地操作资源。也就是说，如果分布式环境下有多个进程/线程/协程要操作同一个资源，那么大家需要先拿到锁，确保同一时刻只有一个人能操作这个资源。

这一类的资源有一个特点，就是如果多个人同时操作的话，会出现数据不一致的场景。最典型的就是分布式任务调度，即某个任务在同一时刻只能有一个人执行。还有类似于更新缓存和数据库的时候，可以用分布式锁来解决并发更新的问题。

某些情况下可以通过优化处理逻辑来规避使用分布式锁。

第一种方式就是通过引入顺序消息。假设说现在 A 和 B 要操作同一个资源，可以让 A 和 B 丢一个消息到消息队列，但是这个消息需要是顺序消息。而后有一个消费者消费这些顺序消息。

第二种方式是使用数据库乐观锁，显然只有需要保护的资源是数据库数据的时候，才能使用这个方式。

> 顺序消息；数据库乐观锁；
>
> 引入顺序消息，数据库乐观锁，逼不得已再用分布式锁；

## 分布式锁解决方案

- 基于数据库的分布式锁实现
  - 实现方式：
    - 排他锁：在数据库中创建一个锁表，通过插入记录来实现锁的获取，通过删除记录来释放锁。
    - 乐观锁：使用版本号或时间戳来检测冲突，适用于读多写少的场景。
  - 优点：
    - 利用现有数据库资源，无需额外部署。
    - 分布式锁是持久化的，宕机之后再恢复锁也还在。
  - 缺点：
    - 性能较低，依赖数据库的可用性。
    - 锁的粒度较粗，容易成为瓶颈。
    - 可能存在死锁问题。
- 基于 Redis 的分布式锁实现
  - 实现方式：
    - 使用SETNX（Set If Not Exists）命令来尝试获取锁。
    - 使用EXPIRE命令设置锁的过期时间，防止死锁。
  - 优点：
    - 性能高，操作简单。
    - 支持多种锁类型和高级特性。
  - 缺点：
    - 依赖Redis的可用性。
    - 在分布式环境下，需要处理时钟同步问题。
    - 考虑 Redis 宕机之后锁就没有了，需要使用 redlock 等解决方案。

也可以利用 Zookeeper、etcd 等中间件的高可靠性和一些特殊机制来实现锁。还有一种比较特殊的基于消息队列的实现，比如RabbitMQ、Kafka，通过独占消费来实现锁。

TODO: 我利用 Go 语言基于 Redis 写过一个分布式锁。它提供了加锁重试、解锁重试、TryLock，手动续约和自动续约功能。整体来说性能很不错，可用性则是完全取决于 Redis。

## 分布式锁三要素

分布式锁的三个基本要素是加锁、释放锁和设置过期时间。

其中加锁，要考虑是否是可重入锁的问题。如果是可重入锁，那么加锁可能对应的是计数增加 1。

释放锁则要注意只能释放自己的锁。也就是在长期运行中，业务方崩溃之后锁被人抢走了，而后业务方又恢复过来，还以为自己有锁，那么就有可能把别人加的锁抢走。

设置过期时间则是为了防止出现死锁。例如说业务方在抢到锁之后崩溃了，如果没有过期时间那么这个锁就再也无法被任何人拿到了。

很容易想到，过期时间不管设置多长时间，业务方都有可能未能在过期时间内完成业务逻辑。所以这个时候就需要引入续约机制，当业务方在发现快要过期了，但是自己又还没结束的时候，延长锁的过期时间。

## CAP 理论

CAP 理论是分布式系统设计中的三个基本属性，分别是：

1. **⼀致性（Consistency）： **即系统在所有节点上的数据是⼀致的。如果在⼀个节点上修改了数据，那么其他节点应该⽴即看到这个修改；

2. **可⽤性（Availability）：** 可⽤性要求系统能够对⽤户的请求做出响应，即使在出现节点故障的情况下仍然保持可⽤；

3. **分区容错性（Partition Tolerance）：** 分区容错性是指系统在⾯对⽹络分区的情况下仍能够正常⼯作。即，当节点之间的⽹络出现故障或⽆法通信时，系统仍能够保持⼀致性和可⽤性。

CAP 理论提出的是在分布式系统中这三个属性不能同时被满⾜。这是由于在分布式系统中，⽹络的不确定性和延迟会导致⽆法同时满⾜⼀致性、可⽤性和分区容错性。

在实践中，分布式系统总是会选择 P，也就是分区容错性。那么剩下的就是 AP 和 CP 之间做选择了。

- 如果选择 CP 模型，也就是你放弃了 A。这个很容易理解，假设说你有两个分区，p1 和 p2。如果你要保证 C （一致性），那么你在写 p1 的时候，就必须同步把这个数据扩散到 p2 上。在这个过程中，p2 是不能对外提供服务的，否则就会出现不一致。因此影响了可用性；
- 如果选择 AP 模型：也就是你放弃了 C。同样的例子，也就是你写入 p1 的时候，根本不管 p2，p2 此时也对外提供服务。那么就有可能从 p2 上读到老数据，引起数据不一致的问题。

## 数据一致性

分布式环境下，数据一致性难以保证主要是由两方面造成的。

一方面是并发更新，也就是有多个线程并发更新同一个数据。举个例子，比如说先更新 MySQL 再更新 Redis 这种缓存更新方案。那么并发更新容易出现的就是线程1 先更新 MySQL，但是后更新 Redis；而线程 2 后更新 MySQL 反而先更新 Redis。这就会导致 MySQL 和 Redis 的数据不一致。

这种不一致是很好的解决的，不管使用版本号来控制，还是用分布式锁来控制，都很好解决。

另一方面就是部分失败，也就是多个操作难以保证它们要么都成功，要么都失败。同样是更新缓存的这个例子，任何一个线程都有可能在更新了 MySQL 之后，更新 Redis 失败。而一旦遇到这种部分失败的问题，完全没有办法解决。最多就是引入重试，但是引入重试之后重试也可能失败。

目前来看，所有的分布式事务解决方案寻求的都是最终一致性。并且如果进一步思考的话会发现分布式事务连隔离性都没解决，这就会导致同一时刻不同线程可能看到完全不同的数据。

## BASE 原理

BASE 是一个缩写，表达了三个特性：

- **基本可用性（Basically Available）**：系统在大多数情况下都能正常响应请求，即使在出现故障或网络分区的情况下，系统仍然能够提供基本的服务。这意味着系统不会因为某个节点的故障而完全不可用。
- **软状态（Soft State）**：系统中的数据状态允许在某个时间点不同步。软状态允许系统在一段时间内存在不一致的状态，这种状态可以通过后续的操作逐渐达到一致。
- **最终一致性（Eventual Consistency）**：经过一段时间后，所有数据节点最终会达到一致的状态。虽然系统在短时间内可能存在数据不一致的情况，但通过一定的机制和策略，最终所有节点的数据会趋于一致。

基本上所有的分布式中间件，业务都是使用 BASE 来作为设计指导思想。比如说：

- 分布式数据库：如 Cassandra、Amazon DynamoDB 等，这些系统通过牺牲强一致性来提高系统的可用性和扩展性。
- 微服务架构：在微服务架构中，各个服务之间通过网络通信，BASE 理论可以帮助设计者在可用性和一致性之间做出权衡。
- 消息队列系统：如 Kafka、RabbitMQ 等，通过异步消息传递和最终一致性来处理分布式事务。

本质上来说，BASE 是因为 CAP 没有办法同时满足才搞出来一个折中方案罢了。它是在 CAP 理论的基础上，针对 AP（可用性和分区容错性）方案进行扩展，提供了一种在实际系统中实现最终一致性的方法。

## 分布式事务

分布式事务是指在分布式系统中，涉及多个节点（如不同的数据库、服务或应用）的事务。它需要保证这些节点上的操作要么全部成功，要么全部失败，以确保数据的一致性和完整性（当然在，这是妄想）。

分布式事务和单体事务还是很不一样的，单体事务只涉及数据库一个组件，ACID 之类的特性还是能满足的，虽然也很复杂。

此外，有些人会说分布式事务也追求 ACID，但是我只能说这个想 P 吃。任何的已有的分布式事务解决方案，差不多都是垃圾，不要说 ACID 全满足，连满足单一的一致性都是要了老命。

常见的分布式事务解决方案：

- 两阶段提交（2PC）
  - 原理：
    - 准备阶段：协调者询问所有参与者是否可以提交事务，参与者执行本地事务并反馈结果。
    - 提交阶段：如果所有参与者都同意，协调者发出提交命令；如果有任何一个参与者不同意，协调者发出回滚命令。
  - 优点
    - 强一致性：确保事务的原子性和一致性。
    - 标准化：广泛支持，易于实现。
  - 缺点
    - 同步阻塞：在准备阶段和提交阶段，参与者需要锁定资源，可能导致长时间阻塞。
    - 单点故障：协调者成为单点故障点。
    - 数据不一致风险：在提交阶段如果协调者崩溃，可能导致数据不一致。
- 三阶段提交（3PC）
  - 原理
    - 预提交阶段：协调者询问参与者是否可以预提交，参与者反馈结果。
    - 准备阶段：如果所有参与者都同意预提交，进入准备阶段，参与者执行本地事务并反馈结果。
    - 提交阶段：如果所有参与者都同意准备，进入提交阶段；否则回滚。
  - 优点
    - 减少阻塞：增加了预提交阶段，减少了阻塞时间。
    - 提高可用性：在一定程度上减少了单点故障的影响。
  - 缺点
    - 实现复杂：相比2PC，增加了阶段，实现更复杂。
    - 仍存在单点故障：协调者依然是单点故障点。
- XA事务
  - 原理
    - 基于XA规范：定义了事务管理器（TM）和资源管理器（RM）之间的接口。
    - 两阶段提交（2PC）：通过2PC协议协调多个资源管理器共同完成事务。
  - 优点
    - 标准化：广泛接受的标准，支持多种数据库和中间件。
    - 强一致性：通过2PC协议确保数据一致性。
  - 缺点
    - 性能开销大：多次网络通信和资源锁定，性能开销大。
    - 单点故障：事务管理器成为单点故障点。
    - 阻塞问题：在准备阶段，资源管理器需要锁定资源，可能导致长时间阻塞。
- TCC（Try-Confirm-Cancel）
  - 原理
    - Try阶段：尝试执行业务操作，但不提交事务。
    - Confirm阶段：如果Try阶段成功，执行确认操作，提交事务。
    - Cancel阶段：如果Try阶段失败，执行取消操作，回滚事务。
  - 优点
    - 灵活性强：适用于复杂的业务场景。
    - 无阻塞：不需要长时间锁定资源。
  - 缺点
    - 实现复杂：需要业务代码实现Try、Confirm、Cancel三个阶段的逻辑。
    - 业务侵入性强：对业务代码有较大侵入性。
- Saga模式
  - 原理
    - 将大事务拆分：将大事务拆分成多个小事务，每个小事务有相应的补偿操作。
    - 顺序执行：按顺序执行小事务，如果某个小事务失败，执行补偿操作回滚。
  - 优点
    - 适用于长事务：适合处理长流程的事务。
    - 高可用性：每个小事务独立执行，系统可用性高。
  - 缺点
    - 实现复杂：需要设计补偿逻辑。
    - 数据不一致窗口：在执行补偿操作前，数据可能处于不一致状态。
- Seata 中的AT事务
  - 原理
    - 自动处理两阶段：通过框架自动处理事务的两阶段提交。
    - 基于.undo日志：在第一阶段记录.undo日志，用于回滚。
  - 优点
    - 无侵入性：对业务代码无侵入性。
    - 自动回滚：自动处理事务的回滚。
  - 缺点
    - 依赖数据库：对数据库有依赖，需要支持.undo日志。
    - 性能开销：记录.undo日志会增加性能开销。
- 最大努力通知
  - 原理
    - 系统A调用系统B：系统A调用系统B后，系统B不断重试通知系统A，直到成功或达到最大重试次数。
  - 优点
    - 实现简单：实现较为简单。
    - 解耦：系统A和系统B解耦。
  - 缺点
    - 一致性保障弱：可能存在长时间未通知成功的情况。
    - 重试开销：频繁重试会增加系统开销。
- 可靠消息最终一致性方案
  - 原理
    - 事务发起方：在执行本地事务成功后，向消息中间件发送一条消息。这部分对应的就是所谓的**本地消息表**解决方案；
    - 消息中间件：负责可靠地存储和传递消息。
    - 事务参与方：从消息中间件接收消息，并执行相应的业务操作。
    - 确认机制：事务参与方在处理完消息后，向消息中间件发送确认消息，消息中间件根据确认情况更新消息状态。
  - 优点
    - 解耦：通过消息中间件解耦事务发起方和事务参与方，系统架构更灵活。
    - 高可用性：消息中间件通常具备高可用性，能够保证消息的可靠传递。
    - 最终一致性：通过消息的可靠传递和确认机制，确保系统的最终一致性。
    - 异步处理：支持异步处理，提高系统的响应速度和吞吐量。
  - 缺点
    - 一致性保障较弱：虽然能保证最终一致性，但在消息处理过程中，系统可能存在短暂的数据不一致状态。
    - 实现复杂度：需要处理消息的持久化、投递、确认等复杂逻辑。
    - 依赖消息中间件：系统的可靠性依赖于消息中间件的稳定性。
    - 消息顺序问题：在分布式环境中，消息的顺序可能无法保证，需要额外处理消息顺序问题。
    - 重复消息处理：可能出现消息重复投递的情况，需要实现幂等性处理机制。
- 延迟事务
  - 原理
    - 用户利用分库分表中间件开启事务
    - 分库分表中间件只有在执行特定语句的时候才会在目标库上开启事务
    - 重试直到成功或者达到最大重试次数
  - 优点：
    - 节省资源：避免在事务不会涉及的数据库上开启事务
  - 缺点：
    - 数据一致性比较差：在出现部分提交成功的情况下，没有任何处理办法

## 两阶段提交

## 三阶段提交

## TCC

## SAGA

