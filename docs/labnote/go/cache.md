# 缓存

## 缓存模式

### Cache Aside

- 把 Cache 当成一个普通的数据源
- 更新 Cache 和 DB 都依赖于开发者自己写代码

**业务代码**可以做决策:

- 未命中的时候是否要从 DB 取数据。如果不从 DB 取，可以考虑使用默认值进行业务处理
- 同步 or 异步读取数据并且写入
- 采用 singleflight

### Read Through

- 业务代码只需要从 cache 中读取数据，cache 会在缓存不命中的时候去读取数据
- 写数据的时候，业务代码需要自己写 DB 和写 cache

**cache** 可以做决策:

- 未命中的时候是否要从 DB 取数据。如果不从 DB 取，可以考虑使用默认值进行业务处理

- 同步 or 异步读取数据并且写入
- 采用 singleflight

### Write Through

- 开发者只需要写入 cache，cache 自己会更新数据库
- 在读未命中缓存的情况下，开发者需要自己去数据库捞数据，然后更新缓存(此时缓存不需要更新 DB 了)

### Write Back

- 在写操作的时候写了缓存直接返回，不会直接更新数据库，读也是直接读缓存
- 在缓存过期的时候，将缓存写回去数据库
- 所有 goroutine 都是读写缓存，不存在一致性的问题(如果是本地缓存依旧会有问题)
- 数据可能丢失:如果在缓存过期刷新到数据库之前，缓存宕机，那么会丢失数据

### Refresh Ahead

refresh-ahead 依赖于 CDC(changed data capture) 接口: • 数据库暴露数据变更接口

- cache 或者第四方在监听到数据变更之后自动更新数据
- 如果读 cache 未命中，依旧要刷新缓存的话，依然会出现并发问题

## 缓存异常

### 缓存穿透

- 读请求对应的数据根本不存在，因此每次都会发起数 据库查询。数据库返回 NULL，所以下一次请求依旧 会打到数据库。
- 关键点就是这个数据根本没有，所以不会回写缓存。
- 一般是黑客使用了一些非法的请求，比如说非法的邮 箱、ID 等。

#### 解决方案

- 使用 singleflight 能够缓解问题。但如果攻击者是构造了大量不同的不存在的 key，那么 singleflight 的效果并不是很好
- 知道数据库里面根本没有数据，缓存未命中就直接返回
  - 缓存里面是全量数据，那么未命中就可以直接返回
  - 使用布隆过滤器、bit array 等结构，未命中的时候再问一下这些结构
- 缓存没有，但是依旧不会去数据库查询，而是使用默认值
- 在缓存未命中回表查询的时候，限流

### 缓存击穿

- 缓存中没有对应 key 的数据。
- 一般情况下，某个 key 缓存未命中并不会导致严重问 题。但是如果该 key 的访问量非常大，大家都去数据 库查询数据，那么就可能压垮数据库。
- 击穿和穿透比起来，关键在于击穿本身数据在 DB 里 面是有的，只是缓存里面没有而已，所以只要回写到 缓存，此一次访问就是命中缓存。

#### 解决方案

- singleflight
- 缓存未命中的时候，使用默认值
- 在回查数据库的时候，限流

### 缓存雪崩

- 同一时刻，大量 key 过期，查询都要回查数据库。
- 常见场景是在启动的时候加载缓存，因为所有 key 的 过期时间都一样，所以会在同一时间全部过期。

#### 解决方案

- 在设置 key 过期时间的时候，加上一个随机的偏移量

> singleflight 设计模式：在有多个 goroutine 试图去数据库加载 同一个 key 对应数据的时候，只允许一个 goroutine 过 去查询，其它都在原地等待结果。
>
> 对数据库的压力本来是跟 QPS 相当，变为跟同一时刻不 同 key 的数量和实例数量相当。

## 缓存一致性

缓存一致性的主要根源**并发更新**和**部分失败**

### 解决方案

- 哈希一致性负载均衡算法 + singleflight，确保某个 key 对应的请求必然打到同一个机器上，唯一可能出现一致性问题是在扩容、缩容和应用重启的过程
- 全局的分布式锁。适合 于强一致性，极端写少的场景

> 可以采用两段式加锁:首先在实例级别上应用 singleflight ，确保一个实例只有一个goroutine 参与全局锁竞争。那么最终有 N 个实例，就是有 N 个 goroutine 去抢分布式锁