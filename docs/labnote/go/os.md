# 操作系统

## 内存管理

虚拟内存的主要作用是提升系统效率和简化内存管理。

1. 内存扩展能力：

- 虚拟内存允许程序运行在比实际物理内存大的地址空间上。即使物理内存不足，系统也可以通过交换（swapping）将不常用的内存页移到磁盘中，使得多个程序能够同时运行。

1. 进程隔离：

- 每个进程拥有独立的虚拟地址空间，防止进程间的内存访问冲突，提高系统稳定性和安全性。
- 使用虚拟内存，操作系统可以通过页面表设置访问权限，防止非法访问。

1. 简化内存管理：

- 操作系统可以更灵活地分配和回收内存，无需手动考虑物理内存布局问题。
- 虚拟内存可以将程序逻辑地址与物理地址解耦。

**虚拟内存**

操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存

操作系统是管理虚拟地址与物理地址之间的关系主要有**内存分段和内存分页**

**内存分段**

程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。**不同的段是有不同的属性的，所以就用分段的形式把这些段分离出来。**

**内存分页**

**分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**。这样一个连续并且尺寸固定的内存空间，我们叫**页**（*Page*）。在 Linux 下，每一页的大小为 `4KB`。

**段页式内存管理**

内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为**段页式内存管理**。

**Linux内存管理**

Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理

## 进程管理

### 进程

在操作系统中，是用**进程控制块**（*process control block，PCB*）数据结构来描述进程的。

### 线程

在早期的操作系统中都是以进程作为独立运行的基本单位，直到后面，计算机科学家们又提出了更小的能独立运行的基本单位，也就是**线程**

**进程间通信**

- 管道
- 消息队列
- 共享内存
- 信号量
- 信号
- socket

### 进程与线程的比较

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；

### 调度

- 先来先服务调度算法
- 最短作业优先调度算法
- 高响应比优先调度算法
- 时间片轮转调度算法
- 最高优先级调度算法
- 多级反馈队列调度算法

### 锁

- 互斥锁：**互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；
- 自旋锁：**自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁；
- 读写锁：**读写锁适用于能明确区分读操作和写操作的场景**。
- 悲观锁：它认为**多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁**。
- 乐观锁：**先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作，乐观锁全程并没有加锁，所以它也叫无锁编程**。

## I/O 模型

- **阻塞I/O（Blocking I/O）**：调用I/O操作时，进程会被阻塞，直到数据准备好或操作完成后才继续执行。
- **非阻塞I/O（Non-blocking I/O）**：I/O操作不会阻塞进程，如果数据没有准备好，立即返回错误或状态，进程可以继续执行其他操作。
- **I/O多路复用（I/O Multiplexing）**：使用`select`、`poll`、`epoll`等系统调用，允许程序同时等待多个I/O操作，当其中任意一个就绪时进行处理。
- **信号驱动I/O（Signal-driven I/O）**：在数据准备好时，内核通过信号通知进程进行I/O操作，进程在接收到信号后再进行数据读取或写入。
- **异步I/O（Asynchronous I/O）**：发起I/O请求后立即返回，内核在后台完成I/O操作，并在操作完成时通知进程。进程不需要等待I/O完成即可继续执行其他任务。

### I/O多路复用

**select**：

- 早期的I/O多路复用机制，使用固定长度的数组表示文件描述符集。每次调用select时都需要重新构建和检查文件描述符集。
- 支持的文件描述符数量有限（通常为1024），在大规模连接的场景下效率较低。

**poll**：

- poll与select类似，但使用动态数组来存储文件描述符，因此没有select的最大连接数限制。
- 每次调用时仍需遍历全部描述符，在处理大量连接时效率不高。

**epoll**：

- epoll是Linux系统对select和poll的优化，提供了边缘触发（ET）和水平触发（LT）模式。
- 不会遍历所有文件描述符，而是通过事件通知的方式，只处理实际发生变化的描述符，适合高并发服务器。
- epoll在注册文件描述符后，只需调用一次添加操作，后续的事件管理更高效。

### Reactor

Reactor 是一种用于处理并发I/O事件的设计模式，特别适合于网络服务器的开发。它通过事件驱动机制和非阻塞I/O，能够高效地处理大量并发连接。

Reactor模式的核心思想是将I/O事件与相应的处理程序解耦，并通过事件分发器（Event Demultiplexer）来管理事件和响应操作。

Reactor的工作方式：

- 事件驱动：Reactor通过监听多个事件源（如Socket连接、读写事件），在有事件发生时调用对应的处理程序（Handler）。
- 非阻塞I/O：使用非阻塞I/O模型，Reactor能够在单个或少数线程中高效处理大量I/O操作，避免了线程的频繁切换。
- 事件分发与处理：Reactor会将收到的事件（如连接到达、数据可读、数据可写）分发给相应的事件处理器，处理器对事件进行处理。

